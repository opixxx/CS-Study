# 네트워크

> [VSFe/Tech-Interview](https://github.com/VSFe/Tech-Interview)

# 1. 쿠키와 세션의 차이에 대해 설명해 주세요
### 쿠키란?
> 클라이언트(브라우저) 측에 저장되는 작은 데이터 조각이다. 사용자가 웹 사이트를 방문할 때마다 브라우저를 통해 서버에 전송된다. 클라이언트, 서버 둘 다 쿠키를 설정 할 수 있으나 서버에서 쿠키를 먼저 설정해서 쿠키를 만드는게 일반적이다.

### 작동 방식
> 서버에서 HTTP 응답의 일부로 쿠키를 클라이언트에 보내고, 이후 클라이언트는 같은 서버에 요청을 보낼 때마다 이 쿠키를 HTTP 요청과 함께 전송한다.  이를 통해 서버는 사용자를 식별하고, 사용자의 선호도나 로그인 상태 등을 기억할 수 있다.

### 세션이란?
> 서버 측에서 사용자 정보를 유지하는 방법이다. 서버는 각 클라이언트에 대한 세션을 생성하고, 고유한 `세션 ID` 를 부여하여 클라이언트와 연결한다.
### 작동 방식
> 클라이언트는 `세션 ID` 를 쿠키를 사용하여 저장하고, 요청마다 이 ID 를 서버에 전송하여 자신을 식별한다. 서버는 이 ID 를 사용하여 해당 사용자의 세션 정보에 접근한다.

### 쿠키와 세션의 차이점
- 쿠키는 클라이언트 측에, 세션은 서버 측에 저장된다.
- 세션이 쿠키보다 보안성이 높다. 쿠키는 클라이언트 측에 저장되므로 변조될 위험이 있다.
- 쿠키는 만료 날짜가 지정되어 있어 브라우저를 종료해도 정보가 남아있지만, 세션은 브라우저가 종료되거나, 설정된 시간 동안 활동이 없을 때 만료된다.

> 세션은 서버의 자원을 사용하기 때문에 사용자의 수가 많아질수록 서버에 많은 영향을 미친다.
> 서버 자원의 낭비를 막고 속도를 높이기 위해 세션과 쿠키를 적절하게 병행하여 사용한다.

## 세션 방식의 로그인 과정에 대해 설명해 주세요
1. 처음 로그인 -> `세션 ID` 가 생성 -> 서버에서 `세션 ID` 를 쿠키로 설정해서 클라이언트에 전달
2. 클라이언트가 서버에 요청을 보낼 때 해당 `세션 ID`를 쿠키로 담아서 전에 로그인 했던 아이디인지 확인
3. 로그인을 유지

## HTTP의 특성인 Stateless 에 대해 설명해 주세요
- HTTP 요청을 통해 데이터를 주고 받을 때 요청이 끝나면 요청한 사용자의 정보 등을 유지하지 않는 것을 말한다.
- 장점 : 서버의 확장성이 높다 -> 서버에 상태를 저장하지 않으므로 서버 확장에 용이하다.
- 단점 : 클라이언트가 데이터를 추가 전송해야 한다.

## Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
> HTTP의 특징이 Statelss 한 것이다. 세션은 그저 인증을 하는 방법 중의 하나인 것이다.
> 다른 예로 Stateless 이면 매번 4-way Handshake를 해야 하는 것 아닌가?
> HTTP와 TCP는 OSI 다른 계층이다. 그렇기 때문에 두 계층을 독립적으로 봐야한다. HTTP의 특징이 Stateless인거지 TCP의 특징이 아니다.


## 규모가 커져 서버가 여러 개가 된다면, 세션은 어떻게 관리할 수 있을까요?
> 여러 개의 서버 중 하나의 서버를 세션을 기반으로 인증을 처리하는 서버로 두는 것이 좋다고 생각한다. 
> 만약 인증 + 다른 도메인을 처리하는 서버가 있을 경우 해당 도메인에서 에러가 발생이 되면 인증에 관한 모든 기능이 마비가 될 수 있기 때문이다. 
> 인증을 처리하는 서버에 에러를 대비해 백업 용을 만들어 놓으면 좋다고 생각한다.

# 2. HTTP 응답코드에 대해 설명해 주세요.

### HTTP 응답코드란
> 서버가 클라이언트의 요청에 대해 응답하는 방식을 나타내는 숫자 코드이다.
> 요청이 성공했는지, 추가 조치가 필요한지, 클라이언트 오류가 발생했는지, 서버 오류가 발생했는지 나타낸다.

### 1xx(정보)
- 서버가 요청을 잘 받았으며 해당 프로세스를 계속 이어가며 처리하는 것을 의미한다.

| 상태 코드 | 상태 텍스트   | 의미          |
|-------|----------|-------------|
| 100   | Continue | **계속 진행하라** |

### 2xx(성공)
- 서버가 요청을 잘 받았고, 클라이언트에게 성공적으로 데이터를 보낸 것을 의미한다.

| 상태 코드 | 상태 텍스트  | 의미                                  |
|-------|---------|-------------------------------------|
| 200   | Ok      | 요청이 성공적으로 되었습니다.                    |
| 201   | Created | 요청이 성공적이었으며 그 결과로 새로운 리소스가 생성되었습니다. |

### 3xx(리다이렉션)
- 서버가 클라이언트의 요청에 대해 완료를 위해 추가 작업 조치가 필요한 것을 의미한다.

| 상태 코드 | 상태 텍스트            | 의미                        |
|-------|-------------------|---------------------------|
| 301   | Moved Permanently | 지정한 리소스가 새로운 URI 로 이동하였다. |
### 4xx(클라이언트 오류)
- 클라이언트가 요청한 페이지를 제공할 수 없거나 요청이 잘못되어 결과적으로 요청을 처리할 수 없습니다.

| 상태 코드 | 상태 텍스트       | 의미                      |
|-------|--------------|-------------------------|
| 400   | Bad Request  | 요청의 구문이 잘못 되었다.         |
| 401   | Unauthorized | 요청한 리소스에 대한 액세스 권한이 없다. |
| 403   | Forbidden    | 요청한 리소스에 대한 액세스가 금지되었다. |
| 404   | Not Found    | 요청 리소스를 찾을 수 없다.        |
### 5xx(서버 오류)
- 서버가 클라이언트의 요청을 처리하지 못하는 상태를 의미한다.

| 상태 코드 | 상태 텍스트               | 의미                                                    |
|-------|----------------------|-------------------------------------------------------|
| 500   | Internal Sever Error | 서버에 오류가 있다.                                           |
| 502   | Bad Gateway          | 게이트웨이 또는 프록시서버가 오류가 생겼다.                              |
| 504   | Gateway Timeout      | 게이트웨이 또는 프록시서버가 정해진 Timeout 시간동안 클라이언트의 요청을 처리하지 못했다. |

## 401(Unauthorized) 와 403(Forbidden)은 의미적으로 어떤 차이가 있나요?

### 401(Unauthorized)
 
> 클라이언트의 요청이 인증을 필요로 함을 의미한다.
> 요청한 리소스를 얻기 위해서는 먼저 인증이 필요하다는 것을 나타낸다.
> ex) 웹 사이트에 로그인을 하지 않고 로그인을 필요한 페이지에 접근하려 할 때

### 403(Forbidden)

> 클라이언트의 요청을 서버가 이해했지만, 클라이언트가 요청한 행동을 수행할 권한이 없음을 나타낸다.
> ex) 관리자 전용 페이지에 일반 사용자가 접근하려고 할 때

### 401 과 403 의 차이점

- `401` 은 올바른 인증 정보가 제공되면 요청이 승인될 수 있지만 `403` 은 이미 인증 과정을 거쳤지만 접근 권한이 없음을 나타낸다.

## 200(ok) 와 201(created) 의 차이에 대해 설명해 주세요.

> 200, 201 둘다 클라이언트의 요청이 성공적으로 이뤄졌다는 의미이지만, 201 은 성공과 동시에 새로운 리소스가 생성되었다는 의미를 포함한다.
> POST, PUT 에 대한 응답에 주로 사용된다.

## 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.
> 기술적으로 서버가 클라이언트에게 어떤 HTTP 응답 코드를 반환할지 결정할 수 있지만, 호환성,가독성,유지 보수 측면에서 생각해봐야 할 부분이 많다.

**호환성** 
- 대부분의 클라이언트는 표준 HTTP 응답 코드를 기대 하고 이를 기반으로 동작한다. 비표준 응답 코드를 사용하면 클라이언트에서 예상치 못한 방식으로 반응할 수 있다.

**가독성과 유지보수**
- 비표준 응답 코드는 개발자나 다른 이해 관계자에게 혼란을 줄 수 있다. 표준 응답 코드는 널리 알려져 있고 문서화가 되어있어 이해하기 쉽지만 비표준 응답 코드는 그렇지 않을 수 있다.

# 3. HTTP Method 에 대해 설명해주세요

### HTTP Method란?

> 클라이언트-서버 구조에서 요청과 응답 데이터를 전송하는 방식을 의미한다.
> 쉽게 말하면 클라이언트의 요청을 서버가 어떻게 수행해야 할지를 알려주는 것이다.

대표적으로 GET, POST, PUT, PATCH, DELETE 가 있다.

- GET : 데이터 조회
- POST : 데이터 생성
- PUT : 데이터를 대체함
- PATCH : 데이터 일부 수정
- DELETE : 데이터 삭제

## HTTP Method의 멱등성에 대해 설명해 주세요.

### 멱등성(Idempotence) 

> 멱등의 사전적 정의는 **연산을 여러번 적용하더라도 결과가 달라지지 않는 성질**을 의미한다.
> 이 의미를 생각하고 HTTP Method 의 멱등성을 설명해보면 **여러번 동일한 요청을 보냈을 때, 서버에 미치는 결과가 달라지지 않는 것**을 의미한다.
> 여기서 생각해야할 점은 멱등성은 **리소스 관점**에서 생각하는 것이다.

| HTTP 메서드 | 멱등성 | 이유                                                           |
|:--------:|:---:|:------------------------------------------------------------:|
| GET      | O   | 같은 요청을 N번 해도 같은 결과가 조회된다.                                    |
| POST     | X   | 같은 요청을 N번 하면 새로운 리소스가 생성되거나 리소스의 상태가 달라져 결과가 달라질 수 있다.       |
| PUT      | O   | 같은 요청을 N번 해도 항상 요청 대상 리소스를 수정하여 동일한 상태로 만든다.                 |
| PATCH    | X   | 기존 리소스에 응답을 추가하는 경우에도 PATCH 가 사용될 수 있으며, 이때 호출 결과가 달라질 수 있다. |
| DELETE   | O   | 같은 요청을 N번 해도 항상 리소스가 없는 동일한 상태이다.                            |
### 멱등성이 왜 필요할까?

> 시간 초과나 기타 일시적인 오류로 인해 정상적인 응답이 수신되지 않는 경우에서 판단을 위한 중요한 근거가 되기 때문이다.

## GET과 POST의 차이는 무엇인가요?

### GET : 데이터를 읽다
- URL 을 기반으로 데이터를 요구하는 방법이다.
- URL 을 기반으로 하기 때문에 길이 제한(2000자미만)이 있다.
- 성공시 HTTP 상태 코드 200을 반환한다.
- 캐싱이 가능하다.
- URL 을 기반으로 요청하기 때문에 해당 요청의 파라미터가 브라우저 기록에 남는다.
- URL 을 기반으로 요청하기 때문에 요청할 때 ASCII 문자열 만을 보낼 수 있다. 
- 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용하지 않는다.

### POST : 데이터를 생성하다.
- URL 이 아닌 HTTP message body 를 통해 전달한다.
- HTTP message body 를 통해 전달하기 때문에 길이 제한이 없다.
- 성공적으로 데이터를 생성할 경우 HTTP 상태 코드 201 을 반환한다.
- 캐싱이 불가능하다.
* URL을 기반으로 요청하지 않기 때문에 해당 요청의 파라미터가 브라우저기록에 남지  않는다. 
*  HTTP message body 로 요청하기 때문에 ASCII 문자열 뿐만 아니라 모든 유형의  데이터를 기반으로 요청할 수 있다. 
*  사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용합니다.  
### GET, POST 의 차이점
> 1. 사용 목적
> - GET : 데이터를 요청할 때
> - POST : 데이터를 생성할 때
> 2. 요청 방법
> - GET : URL 을 기반으로 한다.
> - POST : HTTP message body 을 기반으로 한다.
> 3. 멱등성
> - GET : 멱등이다
> - POST : 멱등이 아니다 

##  POST와 PUT, PATCH의 차이는 무엇인가요?

>  POST는 주로 새 리소스를 생성할 때, PUT은 리소스의 전체를 업데이트하거나 새로 생성할 때, PATCH는 리소스의 일부만을 업데이트할 때 사용됩니다. 
> PUT과 PATCH의 주된 차이점은 PUT이 대상 리소스의 전체를 교체하는 반면, PATCH는 일부분만 수정한다는 점입니다.
> PUT, PATCH 클라이언트가 리소스에 위치를 알고 있다.


## HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

> GET 요청을 브라우저 기록에 남기 때문에 body 에 민감한 데이터가 포함될 경우 보안의 문제가 생길 수 있다. 
> 
> 그리고 body 는 일반적으로 서버로 전송되어 처리될 데이터와 관련이 있기 때문에 의미의 명확성을 위해서 POST 나 PUT 요청의 의미와 더 잘 일치한다.
> 
> - Nginx 같은 경우 GET 요청에 Body에 포함되지 않도록 하고 있다. -> 호환성의 문제
> - Body 에 넣으면 캐싱이 안될 수 있다.

# 4. HTTP에 대해 설명해 주세요.

## HTTP 란?

> HTTP 는 Hyper Text Transfer Protocol 의 약자이며,  처음에는 서버와 브라우저간에 데이터를 주고 받기 위해 설계된 프로토콜이다. 지금은 서버와 서버간의 통신할 때도 많이 이용한다.

## HTTP 의 특징
## 1. Stateless 
 클라이언트의 `state` 를 유지하지 않는다.
- 장점 : 서버 확장(Scale out) 의 용이하다.
- 단점 : 클라이언트가 추가 데이터를 전송해야한다.
  - 쿠키, 세션, 토큰 등을 이용해서 `state` 를 유지한다.

## 2. Connectionless

**Connection Oriented (연결을 유지하는 모델)**

   <img width="529" alt="image" src="https://github.com/user-attachments/assets/9dd7d95e-f771-4603-a09d-9647a12d2738" />

- TCP/IP 의 경우 기본적으로 연결을 유지한다.
- 클라이언트가 요청을 보내지 않더라고 계속 연결을 유지해야한다.
- 연결을 유지하는 서버의 자원이 계속 소모된다.

**Connectionless (연결을 유지하지 않는 모델)**

<img width="515" alt="image 2" src="https://github.com/user-attachments/assets/62f280c9-3faf-46fa-9064-0d6e32b39efa" />

- 요청을 주고 받을 때만 연결을 유지하고 응답을 주고나면 TCP/IP 연결을 끊는다.
  - 위 특징으로 초 단위 이하의 빠른 속도로 응답할 수 있으며, 트래픽이 많은 서비스를 이용해도 실제 서버 동시 처리 요청은 수십개 이하로 매우 작다.
- 최소한의 자원으로 서버 자원을 사용한다.

### Connectionless 의 한계

- TCP/IP 연결을 새로 해야하므로 3 way handshake 시간이 추가가 되어 클라이언트 입장에서 속도가 느려진다.
- 웹 브라우저로 사이트를 요청하면 HTML,CSS,Javascript, 추가 이미지 등 많은 자원이 함께 다운로드할 때 연결을 끊고 연결을 계속 반복하면 비효율적이다.

### Connectionless 의 극복

> 기본적으로 Persistence Connection 으로 문제 해결한다. HTTP/2, HTTP/3 에서 더 많은 최적화되어 있다.


## 공개키와 대칭키에 대해 설명해 주세요.

### 대칭키 암호화 방식
> 대칭키 암호화 방식은 키를 하나만 사용하는 암호화 방식이다.
> 해당 키를 아는 사람만이 문서를 복호화해 볼 수 있다.
> 대표적인 알고리즘으로 DES,  AES가 있습니다.

### 장단점 
> 속도가 빠르다는 장점이 있지만, 키를 교환해야한다는 문제가 있다. 키를 교환하다 키가 탈취될 수 있는 문제가 있고, 사람이 증가할수록 사람마다 키교환을 해야하기 때문에 관리해야 할 키가 많아진다.

### 공개키 암호화 방식
> 두개의 다른 키 (공개키, 개인키) 로 데이터를 암호화하거나 서명하고 키 중 하나인 공개 키를 누구나 사용할 수 있도록 하는 방법이다.
> 공개키로 암호화된 데이터는 개인키로만 복호화 할 수 있다.
> 일반적으로 사용되는 비대칭 암호화 알고리즘은 RSA, DH가 있다.

### 장단점
> 공개키는 키가 공개 되어있기 때문에 키교환이나 키를 분배를 할 필요가 없다. 중간에 공개키를 탈취 당하더라고 개인키로만 복호화가 가능하기 때문에 보안이 좋다. 하지만 속도가 느리다는 단점이 있다.


## 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
> 인증 : 클라이언트에게 서버의 신원을 확인하는 수단을 제공할 수 있다.
> 암호화 : 인증서에는 공개키가 포함되어 있어 대칭키를 암호화 할 수 있다.
> 무결성 : 인증서는 고유한 서명을 생성하여 통신중에 변조되거나 수정되지 않았음을 확인할 수 있다.
> 신뢰 : 클라이언트가 서버에 대한 신뢰를 구축할 수 있다.

## SSL과 TLS의 차이는 무엇인가요?

SSL 과 TLS 는 HTTPS 통신에 사용되는 암호화 프로토콜이다.

### SSL
> 1990 년대 사용되던 프로토콜 이었으나 취약점이 발견되어 현재는 사용되지 않음

### TLS
> SSL 1.0, SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.3 까지 버전이 올라가며 마지막으로 TLS 로 명칭이 변경되었다. 
> 전송 계층에서 보안을 제공하는 프로토콜이다. 클라이언트와 서버가 통신할 때 TLS 를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 한다.




# 5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요 

### 소켓이란?
> 프로그램이 네크워크 상에서 데이터를 송수신을 하기 위한 연결부이다.
> 일반적으로 TCP/IP 프로토콜을 이용한다.
> 소켓은 포트 번호와 결합된 IP 주소로 식별된다.

### 소켓 특징
- TCP/UDP 기반으로 클라이언트와 서버가 직접 네트워크 연결을 설정한다.
- 하위 수준에서 동작하여 바이트 스트림형식의 메시지를 전송한다.
- 브라우저 기반이 아니며 기타 다른 어플리케이션에서 사용 가능하다.
- 클라이언트와 서버 측 모두 소켓 구현이 필요하다.
### 작동 방식
<img width="505" alt="스크린샷 2024-05-15 오후 11 03 02" src="https://github.com/user-attachments/assets/d95bb5c1-2c1b-4a6c-9019-a2beb106348d" />


1. 서버 소켓 생성 : 서버는 특정 포트에서 소켓을 열고 클라이언트의 연결을 대기한다.
2. 클라이언트 소켓 생성 : 클라이언트는 서버의 IP 주소와 포트를 사용해 소켓을 생성하고 연결을 요청한다.
3. 연결 수립 : 서버는 클라이언트의 요청을 받아들여 새로운 소켓을 생성하고 연결을 수립한다.
4. 데이터 통신 : 양방향 데이터 전송이 가능하다.
5. 연결 종료 : 통신이 끝나면 소켓을 닫고 연결을 종료한다.
### 웹소켓이란?
> 단일 TCP 연결을 통해 클라이언트와 서버 간의 실시간 양뱡향 통신을 위해 설계된 특정 프로토콜이다.

### 웹소켓 특징
- 초기 핸드세이크 이후에 연결을 열어둬 효율적인 통신 방법을 제공한다.
  - 데이터 교환에 대해 연결을 다시 설정할 필요 없이 데이터를 주고 받을 수 있다.
- 웹 브라우저, 다양한 장치 및 플랫폼에서 실행하는 웹 어플리케이션에서 사용할 수 있다.

### 작동 방식
1. handshake : 웹 브라우저는 HTTP 요청을 사용해 서버와의 웹소켓 연결을 시작한다.
2. 프로토콜 업그레이드 : 서버는 요청을 받아들여 HTTP에서 웹소켓 프로토콜로 업그레이드 한다.
3. 양방향 통신 : handshake 가 완료되면, 클라이언트와 서버 간에 지속적인 양방향 통신이 가능하다. 실시간 데이터 전송이 용이하다.
4. 연결 유지 : 연결이 닫히거나 명시적으로 종료될 때까지 열린 상태로 유지된다.

## 소켓과 포트의 차이가 무엇인가요?
> 소켓 : 포트 번호와 결합된 IP 주소로 식별하며 네트워크 통신을 위한 인터페이스입니다.
> 포트 : 특정 프로세스를 식별하기 위한 고유한 식별자


## 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
> 포트 번호는 하나의 호스트내에서 고유하지만, 하나의 프로세스는 여러 개의 소켓을 열 수 있으므로 같은 IP, 같은 포트수를 가지고 있다 하더라도 여러 개의 소켓이 존재할 수 있습니다.

## 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
> 사용자의 요청이 많아짐에 따라 서버가 처리해야 할 소켓의 수는 증가할 수 있지만 실제로 **무수히 많은** 소켓이 생성되는지 여부는 서버의 용량, 응용 프로그램의 설계, 사용되는 기술의 특성에 따라 달라진다.

# 6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
### HTTP/1.1(표준 프로토콜)
- HTTP 헤더 + 바디로 구성되어 있다.
  - 헤더에는 URI, Request Method, 여러 헤더 정보가 포함되어있다.
- 사람이 읽을 수 있는 문자열이 그대로 전송된다.
- TCP connection 을 이용한다.
  - 3-way-handshake 를 사용하게 되어있다.
- connection 을 재사용한다.
  - 통신에 사용된 connection 을 즉시 끊지 않고, 대기하였다가 추가 요청이 있을 경우 재활용한다.
- 파이프라이닝 추가
  - 요청에 대한 응답이 끝나기 전에 다음 데이터를 미리 요청한다.

### HTTP/1.1 에 문제들
- 바이너리가 아닌 텍스트로 데이터를 보내는 것
- TCP 를 쓰는 것
- 여전히 요청 데이터가 동기적으로 진행되는 것(1개 요청하고 대기, 도착하면 그 다음 데이터 요청)
- 헤더에 중복된 데이터가 있는 것
### HTTP/2(성능 향상 버전)
> HTTP/1.1 의 문제점을 개선하기 위해 2010년 초중반, 구글에서 SPDY 프로토콜을 기반으로 HTTP2.0 이 등장했다.

### 스트림, 메시지, 프레임
> HTTP/2 에 대해 설명하기 전에 알아야 할 단어들이 몇 가지가 있다.

1. 스트림
   구성된 연결 내에서 전달되는 바이트의 양뱡향 흐름이며, 하나 이상의 메시지가 전달 가능하다.
2. 메시지
   요청/응답에 해당하는 프레임의 전체 시퀀스
3. 프레임
   HTTP/2 통신에서의 최소 단위이며, 각 프레임에는 하나의 프레임 헤더가 포함된다.

> 스트림은 하나 이상의 메시지를 전송하고, 메시지는 **한 개 또는 여러 개의 프레임**으로 구성될 수 있고, 각 프레임은 **프레임 헤더**를 가지고 있으며, **프레임 헤더를 이용하여 어느 스트림에 속하는 지**를 알아
> 낸다.

### HTTP/2 특징

- 모든 통신을 단일 TCP 연결을 통해 이뤄질 수 있고, 스트림의 개수는 제한이 없다.
- 각 스트림은 고유 식별자와 우선수위 정보(선택사항) 이 있다.
- 프레임은 통신의 최소 단위이다. TCP가 데이터를 쪼개서 보낸 다음 헤더를 보고 재 조립 하는 것과 비슷하다.

## HTTP/1.1 과 HTTP/2 의 차이점
### HTTP Body 가 이진 데이터이다.
> 기존 HTTP 는 바디가 문자열로 이루어져있지만 HTTP/2 부터는 `binary framing layer` 라는 공간에 이진 데이터로 전송된다.
> HTTP Request Method, 헤더 등은 여전히 문자열로 전송되지만 바디 부분이 변경되는 것이 가장 큰 변경점 중 하나다.

<img width="600" alt="스크린샷 2024-03-12 오후 11 34 27" src="https://github.com/user-attachments/assets/61e3d101-71bd-4a49-a91c-a8d28894a33f" />


HTTP/2.0은 헤더와 바디 프레임으로 나뉘어 들어가는 것을 볼 수 있다.

### 멀티플렉싱
> 1.0 에서 1.1 으로 넘어오며 pipelining 기술을 도입하였지만, 여전히 `HOL(Head-of-line) Blocking` 문제가 있다.
> `HOL Blocking` 은 패킷이 순서대로 도착해야 하므로, 패킷이 도착할 때까지, 그 이후의 패킷은 전송되지 못하는 것을 의미한다.
> 위의 스트림의 개념을 사용하자면, 1.1 버전에서는 1개의 TCP 연결 당 1개의 스트림만 이용 가능하다. 따라서 하나의 메시지가 응답될 때까지 다른 메시지를 요청하지 못한다. 그래서 여러 TCP 연결을 수립하여 여러 요청을 수행한다. 하지만 2.0 을 이용하면 스트림을 이용하여 다음과 같은 장점이 있다.

- 여러 요청/응답을 병렬로 처리 (하나의 TCP 연결에 여러 **스트림** 사용)
- TCP 연결이 1개이므로 `3-way-handshake` 오버헤드가 없다.
- 네트워크 가용성 증가로 속도 상승 및 이미지 스트라이트 등을 사용하지 않아도 된다.

### 스트림 우선순위 지정

> 1개의 TCP 에 여러 개의 스트림을 사용할 수 있게 되었으므로 각각의 스트림에 우선순위를 둘 수 있게 되었다. 이것을 이용하여 전송 순서를 임의로 고정시킬 수는 없으나, 중요한 데이터를 먼저 보낼 수 있도록 설정하는 것이 가능하다.

### 헤더 압축
> 1.0 에서는 헤더가 문자열로 전송된다. 적게는 500~800바이트 크게는 수 KB를 소모한다. 이러한 성능 이슈를 해결하기 위하여 2.0 에서는 **HPACK** 압축을 이용하여 헤더를 압축하여 보낸다.

### Server push
> 클라이언트에게 필요한 데이터가 있을 때, 직접 요청하기 전에 서버가 미리 데이터를 전송하여 받아볼 수 있게 한다.

이를 통해 여러 TCP 연결을 1개로 합치고, HOL 문제도 해결했다. 
하지만 TCP 프로토콜 자체의 한계 때문에 더 이상 성능 개선에도 한계가 오게 된다.
그러면 TCP 를 쓰지 않는다면 무엇을 쓸까? 같은 전송 계층에 있는 **UDP** 를 쓰게 될 것이다.

## HTTP/3.0의 주요 특징에 대해 설명해 주세요.

HTTP/3.0 프로토콜의 가장 큰 특징은 TCP 가 아닌 UDP 를 사용한다는 것이다.
그전에 TCP, UDP 의 차이점을 간단하게 알아보자

|           | TCP   | UDP  |
|-----------|-------|------|
| 전송속도(상대적) | 느림    | 빠름   |
| 혼잡제어      | O     | X    |
| 헤더크기      | 20바이트 | 8바이트 |
정확히 말하면 HTTP/3.0 은 QUIC 이라는 프로토콜 위에서 돌아가는 HTTP 이다. 
Quick UDP Internet Connection 의 약자로 UDP 를 사용하는 프로토콜이다.

> TCP 는 3-way-handshake, 끝날 때 4-way-handshake 등 오버헤드와 HOL Blocking 등의 문제를 가진다.
> QUIC 은 TCP handshake 과정을 최적화하는 것에 집중하여 설계되었다.


## QUIC 의 장점

### 딜레이 감소

HTTPS over TCP + TLS 에서의 소요되는 레이턴시 : 1 RTT(TCP) + 2 RTT(TLS) = 3 RTT 이다.
HTTPS over QUIC 에서의 소요되는 레이턴시 : 1 RTT

### 멀티플렉싱 지원
<img width="505" alt="스크린샷 2024-03-12 오후 11 53 13" src="https://github.com/user-attachments/assets/1f0a99b4-ed43-4022-a5ce-370762b97439" />

> 멀티플렉싱을 지원하며, 이론 인하여 HOL Blocking 이 없다.

### 네트워크 스위칭 속도 개선
> 매 요청마다 클라이언트 - 서버의 IP 가 필요한 것이 아니고, QUIC 는 Unique connection ID 를 사용해서 모든 패킷이 잘 구별될 수 있도록 한다. 예를 들어 휴대폰으로 인터넷을 할 때, 중간에 와이파이에서 LTE 로 변경해도 스트림이 계속 유지가 된다. (TCP 의 경우에는 처음부터 다시 데이터를 받아와야 한다.)

# 7. TCP와 UDP의 차이에 대해 설명해 주세요.

### TCP(Transmission Controle Protocol)

> 인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜

### TCP 의 특징
- 연결 지향 방식으로 패킷 교환 방식을 사용한다.
- 3-way handshake 과정을 통해 연결을 설정하고 4-way handshake 을 통해 해제한다.
- 흐름 제어 및 혼잡 제어
  - 네트워크 상황과 클라이언트의 데이터 처리 능력을 고려하여 데이터 전송 속도를 조절한다.
  - 네트워크의 혼잡 상태를 감지하고, 혼잡을 완화하기 위해 데이터 전송 속도를 조절한다.
- 높은 신뢰성을 보장한다.
  - 데이터 손실이 발생했을 때 재전송을 요청하고, 도착한 데이터의 순서를 관리하여 데이터를 제공한다.
- UDP 보다 속도가 느리다
- 전이중(Full-Duplex), 점대점(Point to Point) 방식이다.

### UDP(User Datagram Protocol)
> 데이터를 데이터그램 단위로 처리하는 프로토콜

### UDP 의 특징
- 비연결 방식으로 데이터 그램 패킷 교환 방식을 사용한다.
- 신뢰성이 떨어진다
  - 패킷의 도착을 보장하지 않으며, 순서대로 도착한다는 보장도 없다.
  - 데이터 패킷이 손실되거나 순서가 바뀌어도 재전송을 요청하지 않는다.
- 효율적으로 데이터를 전송한다.
  - 연결 설정과 상태 유지에 필요한 오버헤드가 없기 때문에 빠른 데이터 전송이 필요한 실시간 애플리케이션에서 많이 사용된다.
- 헤더 오버헤드가 적다.
  - UDP 헤더는 8 바이트로, 전송해야 할 데이터 양이 적은 경우에 유리하다.
- TCP 보다 속도가 빠르다

밑에 표를 통해 TCP 와 UDP 의 차이를 알아보자

|            | TCP                                                          | UDP                                                   |
|:----------:|:------------------------------------------------------------:|:-----------------------------------------------------:|
| 패킷교환방식     | 가상회선패킷교환방식                                                   | 데이터그램패킷교환방식<br>                                       |
| 신뢰성        | O                                                            | X                                                     |
| 오류검사       | 재전송, 체크섬                                                     | 체크섬                                                   |
| 패킷의 순서보장   | O                                                            | X                                                     |
| 헤더길이       | 20~60 바이트 가변 길이                                              | 8 바이트 고정 길이                                           |
| 연결 보장      | 3-way handshake 로 연결을 맺고 4-way handshake 로 연결을 해제하는 작업이 필요하다 | 연결을 보장하지 않는다.<br>그냥 데이터를 보내고 연결을 유지하고 해제하는데 드는 비용이 없다 |
| 브로드 캐스트 지원 | X                                                            | O                                                     |
| 속도         | 느리다                                                          | 빠르다                                                   |

## Checksum이 무엇인가요?

### Checksum 이란
> 데이터의 정확성을 검증하기 위해 사용되는 간단한 방법 중 하나이다. 주로 파일, 메시지, 혹은 패킷의 무결성을 확인하는 데 사용된다.

### 작동원리
1. 데이터를 전송하기 전에, 전송할 데이터의 내용에 기반하여 계산된 작은 크기의 값(checksum) 을 생성한다.
2. 생성된 checksum 값은 데이터와 함께 수신자에게 전송된다.
3. 데이터를 받은 수신자는 수신된 데이터에 대해 같은 checksum 계산 방법을 사용해 새로운 checksum 값을 계산한다.
4. 두 checksum 을 비교한다. 두 값이 일치하면 데이터가 정확하게 전송된 것이고, 일치하지 않으면 데이터가 변조,손상된 것으로, 데이터 재전송을 요청할 수 있다.

## TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
> TCP 와 UDP 둘다 모두 Checksum 을 수행한다. 
> 하지만 TCP 에서는 필수적이고, UDP 는 선택적이다.

## 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
> Checksum 으로 데이터의 오류의 발생 여부만 확인할 수 있다. 오류가 어디서 어떻게 발생하였는지는 알 수 없다.

## TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
1. ACK 필드를 이용하여 데이터를 수신하였는지 확인하는 요청/응답을 보낸다.
2. 데이터의 순서를 관리한다.
3. 흐름제어 : 수신자가 처리할 수 있는 데이터의 양을 슬라이딩 윈도우 기능을 통해 제어한다.
4. 혼잡제어 : 네트워크 정체 신호를 모니터링하여 네트워크 과부하를 방지한다.
5. 오류감지 : checksum 을 사용하여 데이터의 오류 여부를 검사한다.


## TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.

1. 느린 시작(Slow Start)
   - 연결 시작 시 속도를 점진적으로 늘려, 네트워크 용량을 탐색합니다.
2. 혼잡 회피(Congestion Avoidance) 
   - 네트워크 혼잡을 감지하면, 전송 속도 증가를 늦춰 혼잡을 관리합니다.
3. 빠른 재전송
   - 패킷 손실(예: 타임아웃, 중복 ACK)을 통해 네트워크 혼잡을 감지하고, 손실된 패킷을 빠르게 재전송한다.
4. 빠른 회복(Fast Recovery)
   - 혼잡 발생 시 윈도우 크기를 줄여 빠르게 회복하고, 네트워크 성능을 유지한다.

> Window size : sender 가 보낼 수 있는 최대 데이터 크기
## 왜 HTTP는 TCP를 사용하나요?
> TCP, UDP 의 선택은 신뢰성, 속도를 생각하여 선택해야한다고 생각한다.
> HTTP 는 서버-클라이언트 모델 기반으로 통신을 제공한다. 그러므로 데이터의 무결성과 신뢰성이 중요하다. 그러므로 신뢰성이 좋은 TCP 를 사용한다.

## 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
> HTTP/3 에서 UDP 를 사용하는 것은 성능 향샹과 연결의 효율성을 개선하기 위한 것이다.
> 기본적으로 HTTP/3 은 QUIC 프로토콜 위에서 구현된다.
> QUIC 가 UDP 의 기본적인 특성을 활용하면서도, TCP 에서 제공하는 신뢰성, 순서 보장, 흐름 제어, 혼잡 제어 같은 중요한 기능들을 자체적으로 구현한다. 이를 통해 UDP 의 문제점들이 해결됐다.

## 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
- 무조건 TCP를 씀 -> 응답을 보낼 때 우리 UDP 쓰니깐 UDP에 맞게 보내주세요라는 alt를 보냄
  - 첫번째 요청이 TCP를 하니 온전한 HTTP 누리지 못함
- TCP, UDP 요청을 동시에 보냄 -> 먼저 오는 것을 쓴다.
  - 만약 TCP가 먼저오면 어떡함? -> 3 way handshake 등 시간이 더 걸린다.
  - UDP 요청을 약간 먼저 보내는 경우도 있음

## 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
1. 신뢰성 : 데이터 손실, 중복, 순서 보장이 필요한가?
2. 실시간성 : 데이터 전송의 지연 시간이 중요한가?
3. 오버헤드 : 프로토콜의 오버헤드를 최소화해야 하는가?
4. 데이터 전송 패턴 : 지속적인 스트림 전송이 필요한가, 아니면 개별적인 패킷 전송이 필요한가?
5. 혼잡 제어 : 네트워크 상태에 따라 전송 속도를 조절할 필요가 있는가?

**TCP 를 선택하는 경우**
> 데이터의 신뢰성과 순서 보장이 중요하며, 지연 시간보다 데이터의 정확성이 중요한 애플리케이션
**UDP 를 선택하는 경우**
> 실시간 성능과 낮은 지연 시간이 중요하며, 약간의 데이터 손실을 허용할 수 있는 애플리케이션

# 8. DHCP가 무엇인지 설명해 주세요.
**DHCP 란?**
> Dynamic Host Configuration Protocol 의 약자로 네트워크의 컴퓨터 및 기타 장치에 IP 주소를 할당하기 위한 표준화된 프로토콜입니다.
> DHCP 를 사용하면 네트워크 관리자가 각 장치에 수동으로 IP 주소를 할당하는 번거로움 없이, 장치들이 네트워크에 연결될 때 자동으로 IP 주소, 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소와 같은 필요한 네트워크 구성 정보를 받을 수 있다.
> DHCP 는 네트워크 관리를 단순화하고 IP 주소를 효율적으로 관리할 수 있게 도와준다.

## DHCP는 몇 계층 프로토콜인가요?

> Application 계층이다.  네트워크 장비에 IP 주소와 같은 네트워크 설정을 자동으로 할당해주는 역할이므로 네트워크 상에서 다른 장비들과 통신하는 응용 프로그램이나 서비스와 관련되어 있다.

**DHCP 의 구성요소**
1. DHCP 서버
   - 네트워크 상의 중앙 장치로, IP 주소 및 기타 네트워크 구성 정보를 동적으로 관리하고 할당한다.
2. DHCP 클라이언트
   - 네트워크에 연결하는 장치(컴퓨터, 스마트폰, 태블릿 등)로, DHCP 서버로부터 IP 주소와 네트워크 구성 정보를 동적으로 받는다.
   - DHCP 클라이언트는 네트워크에 연결할 때 자동으로 DHCP 서버에 IP 주소를 요청하고, 할당된 IP 주소의 임대 기간이 만료되면 연장을 요청하거나 새로운 IP 주소를 요청할 수 있다.
3. DHCP 릴레이
   - DHCP 서버와 DHCP 클라이언트는 네트워크 상의 다른 세그먼트에 위치하여 있기 때문에 둘 사이의 중계하는 역할을 하는 장치이다.
   - 
## DHCP는 어떻게 동작하나요?

클라이언트가 DHCP 서버로 IP 주소를 할당받는 과정은 다음 그림과 같이 4단계가 있다.
<img width="798" alt="image 3" src="https://github.com/user-attachments/assets/6f8cf02e-b10f-4bb9-acc4-dc4a7a3748c6" />

1. DHCP Discover
   - 클라이언트는 IP 주소를 요청하기 위해 네트워크 상의 DHCP 서버를 찾아 `DHCP Discover` 메시지를 브로드캐스트 합니다.
2. DHCP Offer
   - DHCP 서버는 `DHCP Offer` 메시지를 통해 클라이언트에게 IP 주소를 제안합니다.
   - 메시지에는 클라이언트에 할당된 IP 주소와 주소의 `임대 시간(Lease Time)`이 포함된다.
3. DHCP Request
   - 클라이언트는 제안받은 IP 주소에 대해 `DHCP Request` 메시지를 통해 수락 의사를 전달합니다. 
   - 이 단계에서 클라이언트는 여러 DHCP 서버로부터 제안을 받았을 수 있으며, 그 중 하나를 선택합니다.
4. DHCP Acknowledgement
   - DHCP 서버는 `DHCP Acknowledgement` 메시지를 통해 IP 주소 할당을 확정하고, 필요한 기타 네트워크 구성 정보(서브넷 마스크, 기본 게이트웨이, DNS 서버 주소)를 클라이언트에게 전달한다.

## DHCP에서 UDP를 사용하는 이유가 무엇인가요?
> TCP를 사용할 수 없어서 UDP 를 사용한다.
> 1. DHCP 는 클라이언트 IP 주소를 요청하기 위해 DHCP 서버의 브로드캐스트를 하지만 TCP 는 브로드캐스트를 지원하지 않는다.
> 2. DHCP 클라이언트는 IP 주소가 없는 상태에서 서버와 통신해야하는데 TCP 는 연결지향형 프로토콜이다.

## DHCP에서, IP 주소 말고 추가로 제공해주는 정보가 있나요?


## DHCP의 유효기간은 얼마나 긴가요?
> 유효기간 = 임대 시간(Lease Time) 을 말한다.
> 유효기간은 DHCP 서버에 의해 설정되고, 네트워크 관리자가 조정할 수 있다.
> 요청이 많은 곳은 짧은 시간으로 설정하고, 요청이 적은 곳은 긴 시간으로 유연하게 유효기간을 설정한다.

# 9. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?	

### IP 란
> IP(Internet Protocol address) 는 컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해서 사용하는 고유한 주소이다. 
> IP 주소는 크게 IPv4, IPv6 로 2가지 버전으로 나뉜다.


### IP 기능
1. 식별 기능
   - 네트워크 내의 각 기기에 고유한 식별자를 제공한다.
2. 위치 지정 기능
   - 데이터 패킷이 올바른 목적지로 전송될 수 있도록 기기의 위치를 지정한다.
3. 네트워크 인터페이스 구분
   - 하나의 기기가 여러 네트워크에 연결되어 있을 때, 각 연결마다 고유한 IP 주소를 통해 구분 될 수 있다.
4. 데이터 전송
   - 인터넷을 통해 데이터를 전송할 때, IP 주소는 소스와 목적지 주소로 사용되어 데이터 패킷이 올바르게 라우팅 되도록 한다.
**IPv4**
> 32 비트 주소 체계를 사용하며,  2^32 개의 주소를 표현할 수 있다.
> 8비트 단위로 점을 찍어 4개로 구분해서 표현하며, 8비트를 10 진수로 표현해서 말한다.
> 인터넷의 급속한 성장으로 이 주소들만으로 부족하기 때문에 NAT, 서브네팅 여러개의 부수적인 기술이 생겨났다.

**IPv6**
> IPv4 의 주소 고갈 문제를 해결하기 위해 등장하였다.
> 128 비트 주소 체계를 사용하며, 2^128 개의 주소를 표현할 수 있다.
> 16비트 8개로 구분하고 16비트는 16진수로 변환되어 콜론(:) 으로 구분하여 표시한다.

## IPv6는 IPv4의 주소 고갈 문제를 해결하기 위해 만들어졌지만, 아직도 수많은 기기가 IPv4를 사용하고 있습니다. 고갈 문제를 어떻게 해결할 수 있을까요?

> 공인 IP(public IP) 와 사설 IP(private IP) 로 나누고 중간 NAT 라는 기술을 통해 해결한다.
> NAT 는 사설 네트워크에서 사용되는 사설 IP 주소를 인터넷에 연결된 단일 공용 IP 주소로 변환합니다. 이를 통해 여러 기기가 하나의 공용 IP 주소를 공유하여 인터넷에 접속할 수 있게 하여, 공용 IP 주소의 사용을 최소화합니다.
## IPv4와 IPv6의 차이에 대해 설명해 주세요.

|             | IPv4                                                 | IPv6                                                         |
|-------------|------------------------------------------------------|--------------------------------------------------------------|
| 무엇인가        | 인터넷 프로토콜 버전 4                                        | 인터넷 프로토콜 버전 6                                                |
| 주소 크기       | 32비트, 2^32개의 IP 주소                                   | 128비트, 2^128개의 IP 주소                                         |
| 명명 표준       | 숫자형 IP 주소, 마침표로 구분된 세 자리 숫자의 4개 묶음<br> ex) 197.0.0.1 | 영숫자 주소, 콜론으로 구분된 4자리 16진수의 8개 묶음 <br>ex) 2600:1400:d:5a3::3bd4<br> |
| 주소 변환 필요 여부 | Network Address Translation(NAT) 을 통해 변환             | 필요 없음                                                        |
| 패킷 주소 지정    | 유니캐스트, 브로드캐스트, 멀티 캐스트                                | 유니캐스트, 멀티캐스트, 애니캐스트                                          |
| 주소 구성       | 수동 및 DHCP 구성                                         | Stateless Address Autoconfiguration(SLAAC)을 사용한 디바이스의 자동 구성, DHCPv6 는 상태 저장 연결에서도 지원됨 |
| 헤더 크기       | 20바이트 ~ 60바이트                                        | 고정, 40바이트                                                    |
| 헤더 체크섬      | O                                                    | X                                                            |

## 수많은 사람들이 유동 IP를 사용하고 있지만, 수많은 공유기에서는 고정 주소를 제공하는 기능이 이미 존재합니다. 어떻게 가능한 걸까요?

## IPv4를 사용하는 장비와 IPv6를 사용하는 같은 네트워크 내에서 통신이 가능한가요? 가능하다면 어떤 방법을 사용하나요?
> IPv4 와 IPv6 는 서로 호환되지 않는 프로토콜이다. 기본적으로는 직접 통신할 수 없다.
> 그러나 두 프로토콜 간의 통신을 가능하게 하는 여러 가지 전환 기술이 있다.

1. 듀얼 스택(Dual Stack)
   - 듀얼 스택 환경에서는 네트워크 장비가 IPv4, IPv6 두 프로토콜을 동시에 지원한다.
   - 장비가 IPv4, IPv6 주소를 모두 가지고 있어 양쪽과 통신할 수 있게 된다.
2. 터널링(Tunneling)
   - IPv6 패킷을 IPv4 네트워크를 통과시키기 위해 IPv6 통신을 IPv4 패킷 안에 캡슐화 한다.
   - 목적지에서 다시 IPv6 패킷으로 추출된다.
3. 프로토콜 변환(Protocol Translation)
   - IPv4와 IPv6 네트워크 간의 게이트웨이에서 사용된다.
   - IPv4 패킷과 IPv6 패킷 간의 상호 변환을 수행하여, 두 네트워크 간의 통신을 가능하게 한다.
   - NAT64는 IPv6 주소를 IPv4 주소로 변환하고, DNS64는 IPv6-only 시스템이 IPv4 주소를 가진 호스트에 접근할 수 있도록 도와준다.

## IP가 송신자와 수신자를 정확하게 전송되는 것을 보장해 주나요?
> IP 자체는 송신자로부터 수신자까지 데이터가 정확하게 전송되는 것을 완전히 보장하지 않는다. 
> IP는 인터넷 계층의 핵심 프로토콜로, 데이터를 패킷으로 분할하고 이를 수신자에게 전달하는 역할을 한다. 그러나 IP는 비연결형 프로토콜이며, 패킷의 순서 보장, 무결성 검증, 재전송 등을 직접 처리하지 않는다.

## IPv4에서 수행하는 Checksum과 TCP에서 수행하는 Checksum은 어떤 차이가 있나요?
**IPv4 체크섬**
* IPv4 헤더 체크섬은 패킷의 헤더만을 대상으로 한다.
* IPv4 체크섬은 패킷의 전송 과정에서 헤더 정보의 무결성을 보장하는 데 초점을 맞춘다. 만약 체크섬이 일치하지 않는 경우, 패킷은 손상되었다고 간주되어 폐기됩니다.
* IPv4 체크섬은 헤더 정보만을 검증하므로, 패킷의 데이터 부분(페이로드)에 대한 무결성 검증은 제공하지 않는다.
**TCP 체크섬**
* TCP 체크섬은 TCP 세그먼트의 전체(헤더 + 데이터)에 대해 계산된다. 이는 데이터의 무결성 뿐만 아니라, 전송 순서와 데이터의 완전성까지도 검증하는 데 도움을 줍니다.
* TCP 체크섬은 세그먼트가 수신지에 도달했을 때 전체 세그먼트를 대상으로 다시 계산되며, 송신 시와 비교하여 검증한다. 이 과정을 통해, 데이터가 네트워크를 통해 정확하게 전송되었는지 확인할 수 있습니다.
* TCP 체크섬은 페이로드 무결성을 보장하기 때문에, 데이터가 손상되었을 경우 재전송을 요청할 수 있다.

**차이점**
1. 적용범위 
   - IPv4 체크섬은 IP 헤더에만 적용되며, TCP 체크섬은 TCP 헤더와 데이터 모두에 적용된다.
2. 목적
   - IPv4 체크섬은 패킷 헤더의 무결성을 확인하는 데 중점을 두고, TCP 체크섬은 전송된 데이터 전체의 무결성과 정확성을 검증한다.
3. 동작 방식
   - IPv4 패킷은 라우터를 거칠 때마다 헤더 체크섬이 재계산되고 검증되는 반면, TCP 체크섬은 송신지와 수신지에서만 계산되어 전체 데이터의 무결성을 확인한다.




## TTL(Hop Limit)이란 무엇인가요?
> IPv4 에서는 TTL(Time to live), IPv6 에서는 홉 제한(Hop limit) 라고 한다.
> 데이터 패킷이 네트워크 상에서 살아남을 수 있는 시간 또는 거쳐갈 수 있는 최대 홉 수를 나타낸다.

## IP 주소와 MAC 주소의 차이에 대해 설명해 주세요.
**MAC 주소**
> MAC(Media Access Control Address) 는 네트워크 인터페이스 카드(NIC) 에 고유하게 할당된 물리적 주소이다.
> MAC 주소는 48비트 또는 64비트 길이며 16진수로 표현된다. 일반적으로 공장에서 제조 시점에 네트워크 장비에 할당되며, 기기의 생산자를 식별하는 부분과 고유 식별 번호로 구성된다.

IP 주소는 소프트웨어적으로 할당된 논리적 주소, 변경 가능
MAC 주소는 하드웨어 고유하게 할당된 물리적 주소, 일반적으로 변경 X

# 10. OSI 7계층에 대해 설명해 주세요.

### OSI 7계층
> 네트워크 통신 과정을 7개의 계층으로 나누어 각 계층이 특정 기능을 담당하도록 설계되었다.

<img width="474" alt="스크린샷 2024-03-20 오전 10 26 57" src="https://github.com/user-attachments/assets/f56a3acf-d4eb-4b96-a9e7-96db610eaea7" />

1. **물리 계층 (Physical Layer)**
   - 물리적인 매체(케이블, 리피터, 허브)를 통해 데이터를 전기적, 기계적, 기능적 신호로 변환하여 전송하는 역할을 한다.
   - 데이터 링크 계층으로 부터 받은 데이터를 비트(bit) 단위로 변환하여 전달한다.
2. **데이터 링크 계층 (Data Link Layer)**
   - 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 통신에서의 오류를 찾고, 재전송하는 기능을 가지고 있다.
   - 프레임 단위로 데이터를 처리하며, MAC 주소를 사용하여 장치를 식별한다.
3. **네트워크 계층 (Network Layer)**
   - 다양한 네트워크 간의 데이터 전송을 담당한다. 
   - 데이터 패킷을 목적지까지 라우팅하는 역할을 하며, IP 주소를 사용하여 장치를 식별한다.
4. **전송 계층 (Transport Layer)**
   - 통신 세션에서 데이터의 전송을 관리한다. 
   - 데이터의 분할, 전송, 재조합을 담당하며, TCP, UDP 와 같은 프로토콜을 사용하여 신뢰성 있는 데이터 전송을 보장한다.
5. **세션 계층 (Session Layer)**
   - 네트워크 상의 두 시스템 간의 세션을 관리한다.
   - 세션의 설정, 유지, 종료를 담당하여 데이터 교환 과정에서의 동기화와 연결을 유지한다.
6. **표현 계층 (Presentation Layer)**
   - 데이터의 표현 형식을 처리한다.
   - 데이터를 암호화하거나 압축하는 등의 변환 작업을 수행하여 애플리케이션 계층과 데이터 링크 계층 사이에서 데이터를 변환한다.
7. **응용 계층 (Application Layer)**
   - 사용자와 바로 연결되어 사용자의 네트워크 서비스 요구를 충족시킨다.
   - 웹 브라우저, 이메일 클라이언트, 파일 전송 프로토콜(FTP)과 같은 응용 프로그램에 서비스를 제공한다.
## Transport Layer와, Network Layer의 차이에 대해 설명해 주세요.

### Transport Layer
> TCP, UDP 가 대표적이며 Application 계층에서 받은 메시지를 기반으로 세그먼트 또는 데이터그램으로 데이터를 쪼개고 데이터가 오류없이 순서대로 전달되도록 도움을 주는 층이다.

### Network Layer
> IP, ICMP, ARP 가 대표적이며 한 노드에서 다른 노드로 Transport 계층에서 받은 세그먼트 또는 데이터그램을 패킷화 하여 목적지로 전송하는 역할을 담당한다.

### 차이점
> 목적과 기능 : 네트워크 계층은 패킷의 목적지까지의 라우팅을 담당하고, 전송 계층은 데이터의 신뢰성 있는 전송을 보장한다.
> 데이터 단위 : 네트워크 계층은 패킷, 전송 계층은 세그먼트(TCP), 데이터그램(UDP) 를 사용한다. 
## L3 Switch와 Router의 차이에 대해 설명해 주세요.

### L3 Switch
> L2 스위치의 기능(고속 패킷 전달 기능) + 라우팅을 하는 장비를 말한다. 라우팅 테이블을 참조해서 IP 패킷에 IP 주소를 담아 보낸다.

### Router
> 라우팅은 하나 이상의 네트워크에서 경로를 선택하는 프로세스를 말한다. 이 라우팅을 하는 장비를 라우터(Router) 라고 한다. 다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고받을 때 `패킷소모 최소화`, `경로 최적화` 하는 장비이다.

### 차이점
> **처리 속도와 성능** : L3 스위치는 고속의 내부 네트워크 트래픽 처리에 최적화된 반면, 라우터는 네트워크 간의 연결과 복잡한 라우팅 정책을 처리하는 데에 초첨을 맞추고 있다.
> 
> **사용 목적과 환경** : L3 스위치는 주로 대량의 데이터를 빠르게 처리해야 하는 LAN 내에서 사용되고, 라우터는 인터넷 접속이나 WAN 환경에서의 데이터 전송을 담당한다.
## 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
- 물리 계층 : 비트
- 데이터링크 계층 : 프레임
- 네트워크 계층 : 패킷, 데이터그램
- 전송 계층 : 세그먼트
- 세션 계층 : 메시지, 데이터
- 표현 계층 : 메시지, 데이터
- 응용 계층 : 메시지, 데이터

## 각각의 Header의 Packing Order에 대해 설명해 주세요.
1. 물리 계층
   - 헤더 : 없음
2. 데이터 링크 계층
   - 헤더 : 송신지 MAC 주소, 수신지 MAC 주소, 이더타입 
   - 패킷 순서와 직접적 관련 정보 없음
3. 네트워크 계층
   - 헤더 : 송신지 IP 주소, 수신지 IP 주소, TTL, 프로토콜 타입
   - 패킷 순서와 관련된 특정 헤더 없음
4. 전송 계층
   - 헤더 : 송신지 포트 번호, 수신지 포트 번호, 시퀀스 번호, 프로토콜 타입
   - 전송 계층의 헤더는 패킷 순서 지정에 중요 역할을함
     - TCP : 헤더에 시퀀스 번호가 포함되어 수신자가 패킷을 올바르게 재정렬한다.
     - UDP : 패킷 순서 지정에 대한 것은 없으며, 수신자는 패킷이 도착하면 처리한다.
5. 세션 계층
   - 패킷 순서와 관련된 특정 헤더 없음
6. 표현 계층
   - 패킷 순서와 관련된 특정 헤더 없음
7. 응용 계층
   - 헤더 : 없음
## ARP에 대해 설명해 주세요.
### ARP (Address Resolution Protocol)
> 논리적인 주소인 IP 주소를 물리적 주소인 MAC 주소로 변환하기 위한 프로토콜
> 그 반대로는 `RARP` 가 있다.

### 동작 과정
1. 해당 IP 주소에 맞는 MAC 주소를 찾기 위해 해당 데이터를 `브로드캐스팅`을 통해 연결된 네트워크에 있는 장치한테 모두 보낸다.
2. 맞는 장치가 있으면 해당 장치는 보낸 장치에게 `유니캐스트`로 데이터를 전달해 주소를 찾게 된다.

<img width="690" alt="스크린샷 2024-03-20 오전 11 34 31" src="https://github.com/user-attachments/assets/221d5d64-7c43-4794-9925-9649438283d9" />

# 11. 3-Way Handshake에 대해 설명해 주세요.

**3-way Handshake 란?**
> TCP/IP 프로토콜을 사용하여 네트워크 상에서 데이터를 전송하기 위한 연결을 설정하는 과정이다
> TCP 연결을 시작할 때 사용되며, 두 호스트 간의 신뢰할 수 있는 연결을 만들기 위해 필요하다.
> 3단계로 구성되어 있고, 이를 통해 양방향 통신이 가능한 연결이 성립된다.

**연결 과정**
1. SYN 단계 : 클라이언트는 서버에 클라이언트의 ISN(초기 시퀀스 번호) 을 담아 SYN 을 보낸다.
2. SYN + ACK 단계 : 서버는 클라이언트의 SYN 을 수신하고 서버의 ISN 을 보내며 승인번호로 클라이언트의 ISN + 1 을 보낸다.
3. ACK 단계 : 클라이언트는 서버의 ISN + 1 한 값인 승인번호를 담아 ACK 를 서버에 보낸다.

![IMG_45904CCBC9B5-1](https://github.com/user-attachments/assets/49766018-0465-4a61-ba2e-dd2a62e1a27a)

## ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
> TCP 헤더 내의 제어 비트를 통해 전달된다. 

<img width="528" alt="스크린샷 2024-04-02 오후 1 52 10" src="https://github.com/user-attachments/assets/f26129e1-05c0-4ab5-9784-a8f17e20cca6" />

## 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
**연결 과정**
1. SYN 단계 : 클라이언트는 서버에 클라이언트의 ISN(초기 시퀀스 번호) 을 담아 SYN 을 보낸다
2. ACK 단계 : 클라이언트의 SYN 을 받고, 이에 대한 응답으로 ACK을 클라이언트에게 보낸다.

**문제점**
**양방향 통신 준비 완료 확인을 안한다.**
> 2번 단계에서 서버가 클라이언트로부터 데이터를 수신할 준비가 되었음을 클라이언트에게는 알린다. 하지만 클라이언트가 서버로부터 데이터를 수신할 준비가 되었는지에 대한 확인이 없기때문에 실제 양뱡향 통신의 준비 상태를 확실하게 파악하기 어렵다.

**신뢰성 있는 연결의 부족**
> 연결 설정 과정에서 패킷 손실이 발생할 경우, `2-Way Handshake` 는 이를 효과적으로 처리하지 못할 수 있다. 이로 인해 연결의 신뢰성이 떨어질 수 있습니다.
예시)
**SYN 패킷 손실** 

1. 클라이언트가 SYN 을 서버로 보냈다.
2. 이 `SYN 패킷`이 어떠한 문제로 인해 손실됐다.
3. 서버는 클라이언트의 연결 요청을 인지하지 못하고, 클라이언트는 서버의 응답을 기다린다.
-> 무한 대기 상태에 빠질 수 있다.

**ACK 패킷 손실**
1. 서버가 클라이언트의 SYN 을 받았고 ACK 로 응답을 했다.
2. 이 `ACK 패킷`이 손실됐다고 가정해보자
3. 클라이언트는 자신의 SYN 요청에 대한 응답을 받지 못했다고 판단하고 연결이 성공적으로 이루어지지 않았다고 생각할 수 있다.
4. 서버는 ACK 응답을 보냈으니 연결이 성공적으로 생각할  수 있다. 
-> 양쪽의 연결 상태가 불일치하게 된다.


## 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?

두 호스트가 동시에 서로에게 연결을 시도하는 상황을 **Simultaneous Open** 라고 한다.

**Simultaneous Open** 
> 각 호스트가 상대방에게 SYN 패킷을 보내 연결을 시도하며, 이 과정에서 각자가 클라이언트와 서버 역할을 동시에 수행한다.

**연결 과정**
1. **A와 B가 동시에 서로에게 SYN 패킷을 보낸다.** 
각 호스트의 SYN 패킷에는 자신의 초기 시퀀스 번호(ISN)가 포함되어 있다. 이는 통상적인 연결 요청과 같으나, 양쪽 모두에서 동시에 발생한다.
2. **A는 B로부터 SYN 패킷을 받고, 이에 대한 응답으로 SYN-ACK 패킷을 보냔다.**
마찬가지로, B도 A로부터 SYN 패킷을 받고, SYN-ACK 패킷으로 응답한다. 이 단계에서 각 호스트는 상대방의 SYN에 대해 ACK를 보내면서 동시에 자신의 SYN에 대한 ACK도 기대한다.
3. **A와 B 모두, 상대방으로부터 받은 SYN-ACK 패킷에 대해 ACK 패킷으로 응답한다.** 
이때, 각 ACK 패킷은 상대방의 초기 시퀀스 번호에 1을 더한 값을 포함하여, 상대방의 SYN-ACK를 올바르게 수신했음을 확인한다.


## SYN Flooding 에 대해 설명해 주세요.

**SYN Flooding 이란?**
> SYN Flooding 은 DDos 의 공격의 한 형태로, 악의적인 목적으로 네트워크 서비스를 중단시키기 위해 사용된다. 이 공격은 3-way handshake 연결 설정 과정을 악용하여 수행된다.

1. 공격자는 대량의 SYN 요청을 목표 서버에게 보내어 서버의 연결 대기 큐를 가득 채운다.
2. 각각의 SYN 요청에 대해 서버는 SYN-ACK 응답을 보내고 클라이언트로부터 ACK 응답을 기다리며 Half-open connection 으로 유지한다.
3. 공격자는 일부러 최종 ACK 를 보내지 않아, 서버의 자원을 소모시키고 새로운 연결 요청을 처리할 수 없게 만든다.
**특징**
* 자원 소진: 서버는 각각의 SYN 요청에 대해 연결 슬롯을 할당한다. 공격으로 인해 이러한 슬롯이 모두 사용되면, 정상적인 사용자의 연결 요청은 서버에 도달할 수 없게 된다.
* 가짜 IP 주소 사용: 공격자는 대개 가짜 IP 주소를 사용하여 SYN 패킷을 생성한다. 이는 서버가 SYN-ACK 응답을 보낼 때, 응답이 도달할 수 없는 주소로 가게 만들어 서버의 자원을 더욱 낭비하게 한다.
* 탐지와 차단이 어려움: 가짜 IP 주소의 사용으로 인해 공격자를 추적하고 차단하기 어렵다.


# 12. 4-Way Handshake에 대해 설명해 주세요

**4-way Handshake 란?**
> 3-way Handshake 는 TCP 의 연결을 할 때 사용한다면, 4-way Handshake 는 세션을 종료하기 위해 사용된다.

**동작 과정**
![image 4](https://github.com/user-attachments/assets/73547fe2-3e71-40aa-a768-f68fbc998911)

1. 클라이언트가 연결을 종료하겠다는 FIN 패킷을 전송한다. 이 때 클라이언트는 FIN_WAIT 상태가 된다.
2. 서버는 FIN 플래그를 받고, 응답 패킷 ACK 를 보낸다. 상태는 CLOSE_WAIT 상태가 된다.
3. 서버가 연결을 종료할 준비가 되면 클라이언트에게 FIN 패킷을 보내고 LAST_WAIT 상태가 된다.
4. 클라이언트는 확인 패킷 ACK 을 보내고 TIME_WAIT 상태가 된다.
## 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
> FIN 플래그를 통해 알 수 있다.

## 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?

**Abrupt Connection release(갑작스러운 연결 해제)**
> RST 패킷을 사용하여 실행된다. RST 패킷은 연결을 즉시 종료시키고, 양쪽 통신 당사자 간에 더 이상의 데이터 전송을 시도하지 않는다.
> 보통 연결 오류가 발생했거나, 보안 문제가 감지되었을 때 빠른 종료가 필요한 경우 사용된다. 이 방법은 연결을 즉시 종료하나, 대기 중이거나 전송 중인 데이터가 손실될 수 있다.

## 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?

> TCP 는 데이터나 제어 패킷(FIN, ACK) 전송 시, 상대방으로부터 예상되는 응답을 일정 시간 내에 받지 못하면 Timeout 이 발생한다. 이 경우 패킷을 재전송하고, 일정 횟수의 재전송을 시도 후에도 응답이 없으면 연결 문제를 감지하고 연결을 종료한다.


## 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?

> 먄약 서버에서 FIN 플래그를 전송하기 전에 전송한 패킷이 라우팅 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생 할 수 있다. 그렇기 때문에 클라이언트는 서버로부터 FIN 플래그를 수신하더라도 일정시간동안 세션을 남겨 놓고 잉여 패킷을 기다리는 TIME_WAIT 상태로 대기한다.



# 13. [www.naver.com] 을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.

> 리다이렉트, 캐싱, DNS, IP 라우팅과 ARP, TCP 연결 구축을 거친 다음 컨텐츠를 다운받게 되고 이 후 브라우저 렌더링 과정을 거쳐 네이버라는 화면이 나타난다. 이 과정을 자세히 알아보자

**리다이렉트**
> 사용자가 처음 요청한 URL 이 아닌, 다른 URL 로 보내는 것을 말한다.

리다이렉트가 있다면 리다이렉트를 진행하고 없으면 그대로 해당 요청에 대한 과정이 진행된다.

**캐싱**
> 캐싱은 요청된 값의 결과값을 저장하고 그 값을 다시 요청하면 다시 제공하는 기술이다.

1. 브라우저 캐시
   - 브라우저 캐시는 쿠키, 로컬 스토리지 등을 포함한 캐시이다.
   - 사용자가 HTTP 를 통해 다운로드 하는 모든 문서를 보유하는 것을 말한다.
2. 공유 캐시
   - 클라이언트와 서버 사이에 있고, 사용자간에 공유할 수 있는 응답을 저장한다.
   - 대표적인 예시로 요청한 서버 앞단에 프록시 서버가 캐싱을 하는 것을 말한다.

해당 요청이 캐싱이 가능한지 가능하지 않은지를 파악한다. 캐싱이 이미 된 요청이라면 캐싱된 값을 반환하고 캐싱이 되지 않은 새로운 요청이라면 그 다음 단계로 넘어간다.

**DNS**
> DNS(Domain Name System) 은 계층적인 도메인 구조와 분산된 데이터베이스를 이용해서 시스템으로 FQDN(Fully Qualified Domain Name) 을 인터넷 프로토콜인 IP 로 바꿔주는 시스템이다.

참고 : FQDN(Fully Qualified Domain Name) 은 호스트와 도메인이 합쳐진 완전한 도메인 이름을 말한다. www 등은 호스트, naver.com 은 도메인이라고 한다.

`www.naver.com` 에 DNS 쿼리가 오면 오른쪽부터 역순으로 [Root DNS] -> [.com DNS] -> [.naver DNS] -> [.www DNS] 과정을 거쳐 완벽한 주소를 찾아 IP 주소를 매핑한다.

**DNS 캐싱**
만약 해당 도메인 이름을 요청했다면 로컬 PC 에 자동적으로 저장된다.

**IP 라우팅**
해당 IP 를 기반으로 IP 라우팅이 일어나고 ARP 과정을 거쳐 실제 서버를 찾는다

**TCP 연결 구축**
브라우¡

## DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요? 
> 도메인 이름에 설정된 웹 서버, 이메일 서버, 또는 그 외의 서비스를 제공하는 서버의 실제 위치를 가리키는 것이다.

## Web Server와 Web Application Server의 차이에 대해 설명해 주세요.

**Web Server**
웹 서버는 주로 정적 컨텐츠를 제공하는 데 사용된다. 정적 컨텐츠란 HTML, CSS, 이미지 파일과 같이 서버에 미리 저장되어 있으며 사용자에 요청에 따라 변경되지 않는 파일들을 의미한다.

웹 서버의 주요 기능은 HTTP 요청을 받아서 요청된 파일을 찾아 사용자에게 돌려주는 것이다.

**Web Application Server**
웹 애플리케이션 서버는 동적 컨텐츠를 생성하고 제공하는데 중점을 둔다. 동적 컨텐츠란 사용자의 요청에 따라 실시간으로 생성되는 컨텐츠로, 서버 사이드 스크립트나 데이터베이스 조회 결과 등을 포함할 수 있다.

웹 애플리케이션 서버는 복잡한 비즈니스 로직을 처리하고, 데이터베이스 연동, 세션 관리, 보안 기능 등과 같은 서비스를 제공한다.

**차이점**
- **컨텐츠 유형**: 웹 서버는 주로 정적 컨텐츠를, 웹 애플리케이션 서버는 동적 컨텐츠를 처리한다.
- **기능과 복잡성**: 웹 서버는 상대적으로 단순한 파일 서비스와 기본 보안, 로드 밸런싱 기능을 제공한다. 반면, 웹 애플리케이션 서버는 비즈니스 로직 처리, 데이터베이스 연동, 트랜잭션 관리 등 복잡한 기능을 제공한다.
- **사용 목적**: 웹 서버는 사용자 요청에 따라 파일을 빠르게 전달하는 데 최적화되어 있는 반면, 웹 애플리케이션 서버는 사용자 요청에 따라 서버에서 데이터를 처리하고 결과를 돌려주는 동적인 작업을 수행합니다.

## URL, URI, URN은 어떤 차이가 있나요?
**URI(Uniform Resource Identifier)**
> URI는 리소스를 유일하게 식별하는 데 사용되는 표준화된 문자열의 집합이다. URI는 웹 리소스의 위치나 이름을 나타내는 데 사용되며, 가장 넓은 범위의 식별자이다. 이 용어는 URL과 URN을 포함하는 상위 개념으로, 리소스를 식별하기 위한 보편적인 방식을 제공한다.

**URL(Uniform Resource Locator)**
> URL 은 가장 흔히 사용되는 URI 의 형태로, 리소스가 실제로 존재하는 위치를 나타낸다.
> URL 은 리소스의 접근하기 위한 구체적인 정보를 포함한다. 

`http://www.naver.com/index.html` 는 `http 프로토콜`을 사용해 `www.naver.com` 도메인에 있는 `index.html` 파일을 가리킨다.

**URN(Uniform Resource Name)**
> URN은 리소스의 위치에 대한 정보 없이 리소스를 유일하게 이름을 붙여 식별한다. URN은 리소스가 현재 어디에 있는지, 어떻게 접근해야 하는지를 설명하지 않는다. 대신, 리소스의 특정한 이름을 제공하며, 이 이름은 리소스의 위치가 변경되어도 변경되지 않는다.

**정리**
- URI 는 리소스를 식별하는 가장 광범위한 표현으로, URL, URN 모두를 포함한다.
- URL 은 리소스의 실제 위치를 나타내고, 웹에서 어떻게 해당 리소스에 접근할 수 있는지를 설명한다.
- URN 은 리소스의 위치나 접근 방법을 제공하지 않고, 리소스에 대한 유일한 이름을 제공한다.

# 14. DNS에 대해 설명해주세요
인터넷 도메인 이름을 IP 주소로 변환해주는 시스템이다. 
`www.naver.com.` 라는 도메인 주소가 있을 때
- Root DNS 서버(.) 
- 최상위 도메인(TLD) DNS 서버(com)
- 하위 도메인 DNS 서버(naver)
  - 추가 하위 도메인(www)
## DNS는 몇 계층 프로토콜인가요?
애플리케이션 계층에서 작동하는 프로토콜
## UDP와 TCP 중 어떤 것을 사용하나요?
UDP를 사용한다.
- TCP가 3-way handshake를 사용하는 반면, UDP는 connection 을 유지할 필요가 없음.
- DNS request는 UDP segment에 꼭 들어갈 정도로 작음
  - DNS query는 single UDP request와 server로부터의 single UDP reply로 구성되어 있음
- UDP는 not reliable이나, reliability는 application layer에 추가될 수 있음. (Timeout 추가나, resend 작업을 통해)

TCP를 사용하는 경우가 있다.
Zone transfer 을 사용해야하는 경우에는 TCP를 사용해야 함.
(Zone Transfer : DNS 서버 간의 요청을 주고 받을 떄 사용하는 transfer)
만약에 데이터가 512 bytes를 넘거나, 응답을 못받은 경우 TCP로 함.

## DNS Recursive Query, Iterative Query가 무엇인가요?
**Recursive Query**
- 클라이언트가 Local DNS 서버에게 특정 도메인 IP 주소를 요청한다.
- 실제 IP 주소를 반환한다.
**Iterative Query**
- DNS recursor 과 Name Server 통신에 사용되는 쿼리이다.
- 반복적으로 쿼리를 보내서 IP 주소를 알아내서 DNS recursor에게 IP 주소를 보낸다.
- DNS recursor에 이미 IP 주소가 캐싱되어 있다면 이 과정은 생략한다.

## DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
**타임 아웃**
일정 시간 후에도 응답을 받지 못하면 손실되었다고 가정하고 그 시점에서 다시 시도하거나 포기한다.


## 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
- TTL 설정 : DNS 레코드가 캐시에 유지될 시간이다. TTL이 만료되면, 캐시된 레코드는 폐기되고 새로운 쿼리가 실행된다.
- 캐시 무효화 : 특정 상황에서 캐시된 DNS 레코드는 무효화하거나 삭제하여 새로운 쿼리를 유도할 수 있다.
- DNS 서버 재구성 : DNS 서버 설정을 조정하여 잘못 캐시된 레코드 문제를 해결한다.
## DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.

**레코드 타입**
- A :  도메인 주소와 IP(IPv4) 를 매핑하는 것
- CNAME : 도메인의 별칭, 도메인 주소를 또 다른 도메인 주소로 이동 시키는 것
- AAAA : A 레코드의 IPv6 버전

**A vs CNAME** 
|       | 장점                           | 단점                       |
|-------|------------------------------|--------------------------|
| A     | 도메인이 바뀌어도 IP는 그래도이므로 유지가 된다. | IP 주소가 변동될시에 일일이 변경해야한다. |
| CNAME | IP가 변동될시에 변경하지 않아도 된다.       | 도메인이 바뀌면 변경해야한다.         |
## hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
**hosts 파일**
호스트 이름에 대응하는 IP 주소가 저장되어 있어서 DNS에서 주소를 제공받지 않아도 서버의 위치를 찾게 해주는 파일이다.

운영 체제는 먼저 로컬 hosts 파일을 참조해서 해당 도메인 이름에 해당하는 IP 주소가 있는지 확인하기 때문에 hosts 의 우선순위가 DNS 보다 높다.

# 15. SOP 정책에 대해 설명해주세요
Same Origin Policy 웹 애플리케이션 보안 모델 핵심 정책 중 하나로, 한 출처(origin)에서 로드된 리소스가 다른 출처의 리소스에 접근하는 것을 제한 한다.

이는 악의적인 스크립트가 사용자의 데이터에 무단으로 접근하거나 조작하는 것을 방지하기 위한 웹 브라우저의 보안 메커니즘이다. 

- 스킴 : http, https, ftp 등
- 호스트 : `www.example.com`
- 포트 : 80, 443, 8080 등
이 세 요소가 모두 동일한 경우 Same-Origin으로 간주되고 접근이 허용된다.
## CORS 정책이 무엇인가요?
CORS(Cross-Origin Resource Sharing) 정책은 웹 브라우저가 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 리소스에 안전하게 접근할 수 있도록 해주는 보안 기능이다.

## Preflight에 대해 설명해 주세요.
Preflight Request는 CORS에서 중요한 역할을 한다. 브라우저는 요청을 보낼 때 바로 보내지 않고 먼저 Preflight Request를 보내 서버와 잘 통신할 수 있는 확인한 후 본 요청을 보낸다.
# 16. Stateless와 Connectionless에 대해 설명해주세요

**Stateless**
서버가 클라이언트의 상태를 가지고 있지 않는 것

**Connectionless**
클라이언트와 서버가 연결을 유지하지 않는 것

## 왜 HTTP는 Stateless 구조를 채택하고 있을까요?
**단순성과 확장성**
- 단순성 : Stateless 구조에서 HTTP 요청이 독립적이며, 서버는 이전의 요청 상태를 유지하지 않는다. 이는 서버 구현을 단순하게 한다.
- 확장성 : 서버가 클라이언트의 상태를 유지하지 않기 때문에, 여러 서버로 요청을 분산하는 것이 용이하다.

**자원 효율성**
- 메모리 및 자원 절약 : 클라이언트의 세션 정보를 메모리에 유지할 필요가 없다.

**안전성**
- 안정성 : 서버가 클라이언트 상태를 유지하지 않기 떄문에 서버 중단이나 장애 시 클라이언트의 상태 정보가 손실될 위험이 없다. 시스템의 안정성을 높인다.


## Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?

**Connectionless의 한계**
- 매 연결 시 3-way handshake, 4-way handshake로 연결을 맺고 끊음을 해야하므로 많은 오버헤드가 발생한다.

HTTP Keep-alive 기능을 통해 연결을 끊지 않고 유지한다. 클라이언트는 동일한 연결을 통해 추가 요청을 보낼 수 있다.
## TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?
**TCP keep-alive**
- TCP 계층에서 연결을 주기적으로 확인하기 위해 ACK 패킷을 주고 받는 행위
- ACK을 정상적으로 받지 못하면 OS에서 연결을 종료

**HTTP keep-alive**
- HTTP 계층에서 일어나는 HTTP Connection을 유지하기 위한 매커니즘
- keep-alive 시간 동안 HTTP 요청을 받지 못하면 TCP Connection 종료
- Application 에서 관리

 **TCP keepalive는 서버간에 ACK 패킷을 보내 세션 테이블이 지워지지 않고 계속 세션 정보를 유지하는데 반해, HTTP Keepalive는 일정시간이 지나면 능동적으로 연결을 끊는다**
# 17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.
**라우터란?**
> 네트워크 사이에서 데이터를 전달하는 장치이며, 보통 둘 이상의 서로 다른 네트워크에 연결된다.
> 패킷(데이터) 을 목적지로 보낼 때 최적의 경로를 결정하고 경로가 결정되면 해당 경로로 데이터를 넘겨주는 일(**라우팅**)을 수행한다. 라우터는 라우팅 테이블을 기반으로 패킷을 다음 목적지로 전달한다.
**라우터의 구조**
1. 입력 포트
   - 패킷을 수신하고, 라우터 내부로 전달한다.
   - 패킷의 프레임을 해제하여 네트워크 계층 패킷을 추출합니다.
2. 출력 포트
   - 라우터 내부에서 처리된 패킷을 목적지로 전송한다.
   - 패킷을 프레임으로 감싸고 물리적 매체로 전송한다.
3. 포워딩 엔진
   - 패킷이 도착할 때 가장 적절한 출력 포트를 결정한다.
   - 패킷 헤더를 검사하고, 라우팅 테이블을 조회하여 적절한 경로를 찾는다
4. 라우팅 프로세서
   - 라우팅 테이블을 관리하고, 라우팅 프로토콜을 실행한다.
5. 스위칭 패브릭
   - 입력 포트에서 출력 포트로 패킷을 전달하는 고속 데이터 경로
   - 포워딩 엔진의 결정에 따라 패킷을 적절한 출력 포트로 이동시킨다.

**라우팅 테이블**
> IP 주소를 기반으로 라우터의 위치를 저장한 테이블 또는 데이터베이스이고, 다양한 네트워크에 대한 정보와 해당 네트워크에 연결하는 방법이 포함되어 있다.

<img width="379" alt="스크린샷 2024-05-17 오후 1 35 35" src="https://github.com/user-attachments/assets/ad2d15db-b7db-4389-b4b0-359e916f8d2e" />

**라우팅 테이블의 구성요소**
- 네트워크 대상(Network Destination) : 목적지 네트워크의 IP 주소 
- 서브넷 마스크(Netmask) : 대상 주소를 설명할 때 쓰이는 값. 
* 게이트웨이(Gateway): 이 장치와 연결되어있는 홉, 패킷이 전달되는 다음 IP  주소(외부 네트워크와 연결된 장치) 만약 목적지가 로컬 네트워크라면 “연결됨(connected)”라고 표기 되며 다른 네트워크라면 해당 네트워크의 게이트웨이를 가리킨다. 
* 인터페이스(interface): 게이트웨이로 가기위해 거치는 장치 / 10.0.0.2는 eth3을 통해 접근이 가능. 
- 메트릭(Metric): 우선순위라고도 불리며 패킷 전송을 위해 최적의 경로가 선택되도록 참고되는 값. 동일한 라우팅테이블 요소가 2개 있을 때 이 값이 낮은 요소가 선택된다. 메트릭은 일반적으로 홉 수(hop count)가 들어가며 지연시간, 처리량 등이 들어갈 수 있다.  
**포워딩이란?**
> 라우터의 입력 포트에서 출력 포트로 패킷을 이동시키는 것이다.
> 포워딩에는 **destination-based** 방식과 **generalized** 방식이 있다.

**destination-based forwarding**  : 목적지 IP 주소를 기반으로 포워딩한다.
**generalized forwarding** : 목적지 IP 주소 외에도 데이터그램의 우선순위, 들어온 입력 포트, 출력 포트등 여러가지 요소가 포워딩에 관여한다.

**포워딩 동작 과정**
1. 패킷 수신
   - 라우터의 네트워크 인터페이스 카드(NIC)는 인입되는 패킷을 수신한다.
2. 패킷 헤더 검사 
   - 라우터는 패킷의 헤더를 분석하여 목적지 IP 주소를 확인한다.
3. 라우팅 테이블 조회
   - 라우터는 목적지 IP 주소를 기반으로 라우팅 테이블을 조회한다.
4. 출력 인터페이스 결정
   - 라우팅 테이블 조회 결과를 기반으로, 패킷을 전달할 다음 홉과 출력 인터페이스를 결정한다.
5. 패킷 수정
6. 패킷 전송
   - 결정된 출력 인터페이스로 패킷을 전송합니다.

목적지 IP 주소 192.168.2.10 인 패킷이 라우터에 도착했을 때의 과정
1. 패킷 수신 
   - 라우터의 인터페이스 eth0에서 패킷을 수신한다.
2. 페킷 헤더 검사 
   - IP 헤더에서 목적지 IP 주소 192.168.2.10 을 추출한다.
3. 포워딩 테이블 조회 
   - 포워딩 테이블에서 192.168.2.0/24 네트워크를 찾는다.
   - 해당 항목의 다음 홉이 192.168.1.1이고, 출력 인터페이스가 eth1로 설정되어 있다고 가정하자.
4. 출력 인터페이스 결정
   - 다음 홉 192.168.1.1을 향해 패킷을 전송하기 위해 출력 인터페이스 eth1을 선택한다.
5. 패킷 수정
   - TTL 값을 1 감소시키고, 새로운 TTL 값을 설정한다.
6. 패킷 전송
   - 패킷을 출력 큐에 넣고, 네트워크 인터페이스를 통해 패킷을 다음 홉으로 전송한다.

## 라우팅과 포워딩의 차이는 무엇인가요?
**라우팅**
* **정의**: 라우팅은 패킷이 소스에서 목적지까지 이동하는 경로를 결정하는 과정이다.
* **기능**:
  * 라우터는 라우팅 알고리즘을 사용하여 네트워크 전체의 최적 경로를 계산한다.
  * 라우팅 테이블은 이러한 최적 경로 정보를 저장하며, 네트워크 토폴로지의 변화에 따라 동적으로 업데이트된다.
* **비유**: 여행 계획 세우기.
  * 여행자가 여행 경로를 계획하는 것처럼, 라우팅은 소스에서 목적지까지의 전체 경로를 계획하고 최적의 경로를 선택하는 과정이다.
**포워딩**
* **정의**: 포워딩은 라우터의 입력 링크로 들어온 패킷을 적절한 출력 링크로 이동시키는 과정이다.
* **기능**:
  * 패킷이 라우터에 도착하면, 라우터는 포워딩 테이블을 조회하여 패킷을 올바른 출력 포트로 전달한다.
  * 이 과정은 패킷의 목적지 IP 주소를 기반으로 이루어지며, 포워딩 테이블의 항목과 일치하는 경로를 찾아 패킷을 다음 홉으로 전달한다.
* **비유**: 한 번의 교차로를 통과하는 과정.
  * 마치 여행자가 교차로를 통해 목적지를 향해 진행하는 것처럼, 포워딩은 단일 라우터 내에서 패킷을 적절한 출력 링크로 이동시키는 과정이다.
## 라우팅 알고리즘에 대해 설명해 주세요.
| **알고리즘**                    | **주요 특징**           | **장점**                   | **단점**                           |
|-----------------------------|---------------------|--------------------------|----------------------------------|
| 거리 벡터 <br>(Distance Vector) | 인접 라우터와 거리 정보 교환    | 구현이 간단                   | 대규모 네트워크에서 루프 발생 가능, 수렴 시간 오래 걸림 |
| 링크 상태 <br>(Link State)      | 네트워크 전체 링크 상태 정보 사용 | 빠른 수렴, 루프 없음             | 초기 오버헤드 큼, 메모리 및 계산 요구 사항 높음     |
| 경로 벡터 <br>(Path Vector)     | 경로 전체 정보 포함, BGP 사용 | 루프 방지, 자치 시스템 간 경로 선택 유용 | 경로 벡터 크기 큼, 경로 선택 기준 복잡          |
| 하이브리드<br> (Hybrid)          | 거리 벡터와 링크 상태 결합     | 빠른 수렴, 효율적 자원 사용         | 구현 복잡, 높은 메모리 및 계산 요구            |

## 포워딩 테이블의 구조에 대해 설명해 주세요.
1. 목적지 네트워크 (Destination Network):
   * 네트워크 주소와 서브넷 마스크를 포함하여 목적지 IP 주소의 범위를 정의합니다.
   * 예: 192.168.2.0/24는 192.168.2.0부터 192.168.2.255까지의 IP 주소를 포함하는 네트워크를 의미합니다.
2. 다음 홉 주소 (Next Hop Address):
   * 패킷이 최종 목적지에 도달하기 위해 다음으로 전달될 라우터의 IP 주소입니다.
   * 예: 패킷이 192.168.1.1을 거쳐 가야 하는 경우, 다음 홉 주소가 192.168.1.1입니다.
3. 출력 인터페이스 (Output Interface):
   * 패킷을 다음 홉으로 전달하기 위해 사용할 라우터의 네트워크 인터페이스입니다.
   * 예: eth0, eth1 등.
4. 메트릭 (Metric):
   * 경로의 비용 또는 우선순위를 나타내는 값입니다. 여러 경로가 존재할 때 최적의 경로를 선택하는 데 사용됩니다.
   * 예: 메트릭 값이 낮을수록 경로가 더 선호됩니다.

# 18. 로드밸런서가 무엇인가요?
> 네트워크 트래픽을 여러 서버로 분산하여 특정 서버에 과부하가 걸리지 않도록 해 시스템 성능과 안정성을 향상시키는 장치 또는 소프트웨어이다.

**주요 기능**
1. 트랙픽 분산
   - 클라이언트의 요청을 여러 서버에 분산하여 서버 간의 부하를 균등하게 유지한다.
2. 확장성
   - 서버 수를 동적으로 조절할 수 있어, 트래픽 증가 시 새로운 서버를 추가하여 처리 용량을 확장할 수 있다.
   - 반대로, 트래픽이 감소하면 서버를 줄여 비용을 절감할 수 있다.


## L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요

**L4 로드밸런서**

<img width="713" alt="스크린샷 2024-05-20 오전 10 06 02" src="https://github.com/user-attachments/assets/33ddb4bb-361c-4c18-b85e-ea13b13a454c" />

L4 로드밸런서는 전송 계층에서 작동하며, IP 주소와 포트 번호를 기반으로 트랙픽을 분배한다.

**L7 로드밸런서**

<img width="731" alt="스크린샷 2024-05-20 오전 10 28 03" src="https://github.com/user-attachments/assets/bd7f87a9-b191-4c5a-8df5-ae4ab6a1c4bf" />

L7 로드밸런서는 애플리케이션 계층에서 작동하며, HTTP/HTTPS 등의 프로토콜 데이터를 기반으로 트랙필을 분배한다.

|         | L4 로드밸런서                                                     | L7 로드밸런서                                                     |
|---------|--------------------------------------------------------------|--------------------------------------------------------------|
| 네트워크 계층 | 전송계층(Transport Layer)                                        | 응용계층(Application Layer)                                      |
| 특징      | TCP/UDP 포트 정보를 바탕으로 함                                        | TCP/UDP + HTTP의 URI, FTP의 파일명, 쿠키 정보를 바탕으로 함                 |
| 장점      | - 데이터 안을 들여다보지 않고 패킷레벨에서만 로드를 분산하기 때문에 속도가 빠름<br><br>- L7 보다 저렴함<br> | - 트래픽의 세부 내용을 이해하고 분석할 수 있어, 더 정교한 로드밸런싱이 가능함<br>            |
| 단점      | - 패킷의 내용을 볼 수 없기 때문에 정교한 라우팅이 불가능함<br><br>- 사용자의 IP 가 수시로 바뀌는 경우면 연속적인 서비스 제공하기 어려움 | - 패킷의 내용을 복호화해야 하기때문에 더 높은 비용 발생<br><br>- 클라이언트와 로드밸런서와 인증서를 공유해야하기 때문에 로드밸런서를 통해 데이터를 접근할 보안상의 위험성이 존재함 |


## 로드밸런서 알고리즘에 대해 설명해 주세요.
1. 라운드 로빈
   - 각 서버에 순차적으로 트래픽을 분배한다.
   - 모든 서버가 동일한 수의 요청을 처리한다.
2. 가중 라운드 로빈
   - 각 서버에 가중치를 부여하여, 가중치가 높은 서버에 더 많은 트래픽을 분배한다.
3. 최소 연결
   - 현재 연결 수가 가장 적은 서버에 트래픽을 분배한다.
   - 동적으로 각 서버의 부하 상태를 고려한다.
4. 최소 응답 시간
   - 응답 시간이 가장 짧은 서버에 트래픽을 분배한다.
   - 서버의 현재 부하 상태와 성능을 반영한다.
5. 랜덤 알고리즘
   - 서버를 무작위로 선택하여 트래픽을 분배한다.
6. 고정 비율
   - 사전에 정의된 가중치에 따라 서버에 트래픽을 분배한다.
   - 서버의 성능에 따라 비율을 설정한다.

## 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?

해당 장비의 상태를 지속적으로 모니터링하고, 문제가 발생한 장비를 자동으로 제외하는 매커니즘이 필요하다.
이를 위해서 로드밸런서는 헬스 체크(Health Check) 라는 기능을 사용한다.

1. ICMP
   - ICMP 프로토콜을 사용하여 서버에 Ping 을 보내고 응답을 확인한다.
   - 서버가 Ping 에 응답하지 않으면 문제가 있는 것으로 간주한다.
2. TCP 연결 테스트
   - 특정 포트로 TCP 연결을 시도하여 서버의 가용성을 확인한다.
   - 연결이 실패하면 서버가 문제가 있는 것으로 간주한다.
3. HTTP/HTTPS 
   - 서버의 특정 URL 로 HTTP/HTTPS 요청을 보내고 응답 상태 코드를 확인한다.
   - 응답 상태 코드가 200 OK 가 아니거나 응답이 없으면 서버가 문제가 있는 것으로 간주한다.

## 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.

**DNS 라운드 로빈**
여러 IP 주소를 동일한 도메인 이름에 매핑하여, DNS 쿼리 요청에 대한 순차적으로 다른 IP 주소를 반환하는 방식이다.

1. DNS 레코드 설정
   - 동일한 도메인 이름에 대해 여러 A 레코드를 생성한다.
> www.example.com, IN A 192.168.1.1
> www.example.com, IN A 192.168.1.2
> www.example.com, IN A 192.168.1.3

2. DNS 서버는 클라이언트의 DNS 쿼리에 대해 라운드 로빈 방식으로 순차적으로 IP 주소를 반환한다.
   - 첫 번째 요청 : 192.168.1.1
   - 두 번째 요청 : 192.168.1.2
   - 세 번째 요청 : 192.168.1.3
   - 네번째 요청 : 192.168.1.1
- 구현이 간단하며, 별도의 로드밸런서 장비가 필요없다.
- 서버의 상태를 모니터링하지 않기 때문에, 장애가 발생한 서버로 트래픽이 전송될 수 있다.
- DNS 의 결과가 캐싱되어 일정시간동안 같은 클라이언트의 요청이 같은 서버로만 전달되어 로드밸런싱의 실효성이 떨어질 수 있다.

# 19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.

**서브넷 마스크**
서브넷 마스크는 IP 네트워크를 더 작은 서브 네트워크로 나누기 위해 사용되는 32비트 주소이다.
서브넷 마스크는 네트워크 부분과 호스트 부분을 구분하는데 사용된다.

**서브넷 마스크 구조**
서브넷 마스크는 32비트의 이진수로 표현되고, 네트워크 부분을 나타내는 비트는 1로, 호스트 부분을 나타내는 비트는 0 으로 설정된다.

<img width="593" alt="스크린샷 2024-05-21 오전 11 44 00" src="https://github.com/user-attachments/assets/8d1348f6-6ff4-4688-b371-9e1a745c7430" />

**게이트웨이**
한 네트워크에서 다른 네트워크로 데이터를 전달하는 출입구 역할을 하는 네트워크 장치이다. 게이트웨이는 보통 라우터의 역할을 하며, 서로 다른 네트워크 간의 트래픽을 중계한다.

서로 다른 네트워크상의 통신 프로토콜을 적절히 변환해주는 역할을 한다.

## NAT에 대해 설명해 주세요.
**NAT(Network Address Translation)**
네트워크 장비가 내부 네트워크의 사설 IP 주소를 공인 IP 주소로 변환하거나 그 반대로 변환하는 기술이다.
IPv4 의 주소 부족 문제를 해결하고, 내부 네트워크의 보안을 강화하기 위해 사용된다.

<img width="475" alt="스크린샷 2024-05-21 오후 12 06 33" src="https://github.com/user-attachments/assets/cca0d78f-55c0-4479-9dae-dc1cfdf7494c" />

## 서브넷 마스크의 표현 방식에 대해 설명해 주세요.
1. 이진수 표기법
   - 255.255.255.0 -> 11111111.11111111.11111111.11111111.00000000
2. 점-십진수 표기법
   - 11111111.11111111.11111111.11111111.00000000 -> 255.255.255.0 
3. CIDR 표기법
   - IP 주소 : 192.168.1.0 서브넷 마스트 : 255.255.255.0 을 CIDR 표기법으로 나타내면 192.168.1.0/24 이다. 여기서 /24 는 네트워크 부분이 24비트임을 나타낸다.
## 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?

서브넷 마스크는 연속적인 1비트와 0비트로 구성되어야한다. 비연속적인 서브넷 마스크는 네트워크 주소 계산과 라우팅에 문제를 일으킬 수 있다.

# 20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해주세요

<img width="760" alt="스크린샷 2024-05-22 오후 1 56 54" src="https://github.com/user-attachments/assets/3ae1b442-4fd7-430b-a9de-8f71b9e5965a" />

**멀티플렉싱**
여러 개의 데이터 스트림을 하나의 통신 채널로 결합하는 과정이다.  

여러 애플리케이션들이 전송계층으로 메시지를 전달하면 전송계층에서는 헤더를 붙여서 캡술화하고 네크워크 계층으로 일렬로 내려보낸다.

**디멀티플렉싱**
하나의 통신 채널로 결합된 여러 데이터 스트림을 다시 개별 스트림으로 분리하는 과정이다.

헤더정보를 보고 알맞은 각 애플리케이션 소켓으로 전달하는 것이다.

**멀티플렉싱/디멀티플렉싱 과정**

**TCP 멀티플렉싱**
1. 웹 브라우저(포트 49152) 와 이메일 클라이언트(포트 49153)가 각각 서버의 웹 서버(포트 80) 와 이메일 서버(포트 25) 에 데이터를 전송한다.
2. 이 두 애플리케이션의 데이터는 각각 TCP 세그먼트로 캡슐화된다.
3. TCP 세그먼트는 IP 패킷으로 캡슐화되어 네트워크를 통해 전송된다.

**TCP 디멀티플렉싱**
1. 서버는 IP 패킷을 수신하고, TCP 세그먼트를 추출한다.
2. TCP 헤더의 포트번호(80, 25) 를 기반으로 세그먼트를 웹 서버와 이메일 서버에 전달한다.
3. 웹 서버는 포트 80에서, 이메일 서버는 포트 25 에서 데이터를 처리한다.
# 21. XSS에 대해서 설명해 주세요.

**XSS(Cross-Site Scripting)**
웹사이트에 악성 스크립트를 주입하는 행위를 말한다. 악성 스크립트가 포함된 게시글을 열람한 피해자들의 쿠키는 해커에게 전송됩니다. 이를 통해 해커는 피해자의 브라우저에서 스트립트를 실행해 사용자의 세션을 가로채거나, 웹사이트 변조하거나, 악의적인 컨텐츠 삽입하거나, 피싱 공격등을 시도할 수 있게 된다.
**반사형 XSS**
- 악성 스크립트가 즉시 실행되며, 주로 URL 파라미터, 폼 입력 등을 통해 전달된다.
- 사용자가 악성 링크를 클릭할 때 발생한다.
- 공격 시나리오 
  1. 공격자가 악성 링크를 생성하여 사용자를 유도한다.
  2. 사용자가 링크를 클릭하면, 악성 스크립트가 웹 서버에 전송된다.
  3. 서버는 스크립트를 포함한 응답을 사용자에게 반환하고, 브라우저는 이를 실행한다.
**저장형 XSS**
- 악성 스크립트가 서버에 영구적으로 저장되며, 여러 사용자에게 실행될 수 있다.
- 주로 게시판, 댓글, 프로필 정보 등에서 발생한다.
* 공격 시나리오
  1. 공격자가 악성 스크립트를 웹 애플리케이션에 저장한다.
  2. 다른 사용자가 저장된 데이터를 조회할 때, 악성 스크립트가 브라우저에서 실행된다.

**DOM 기반 XSS**
* 클라이언트 측에서 발생하며, 악성 스크립트가 DOM(Document Object Model)을 조작하여 실행된다.
* 서버와의 상호작용 없이 클라이언트 측에서 발생한다.
* 공격 시나리오
  1. 공격자가 악성 URL을 생성하여 사용자를 유도한다.
  2. 사용자가 링크를 클릭하면, 브라우저에서 자바스크립트가 실행되어 DOM을 조작한다.
  3. 악성 스크립트가 DOM에서 실행되어 공격이 발생한다.


## CSRF랑 XSS는 어떤 차이가 있나요?
**CSRF(Cross-Site Request Forgery)**
공격자가 사용자를 속여, 사용자의 권한으로 악의적인 요청을 특정 웹 애플리케이션에게 보내게 하는 공격이다.
주로 서버 측에서 발생하며, 사용자의 권한을 이용하여 서버에 요청을 보낸다.

공격 시나리오
1. 공격자는 사용자가 인증된 세션을 유지하고 있는 동안, 악성 요청을 특정 웹 애플리케이션으로 보내도록 한다.
2. 사용자가 악성 링크를 클릭하거나 악성 스크립트가 포함된 페이지를 방문하면, 브라우저는 자동으로 요청을 전송한다.
3. 서버는 요청이 유효한 사용자로부터 온 것인지 구별하지 못하고, 해당 요청을 처리한다.

사용자의 권한으로 악의적인 작업 수행 (예시 : 계좌이체, 비밀번호 변경, 게시물 작성 등)

| **특성** | **XSS** | **CSRF** |
|---|---|---|
| **공격 대상** | 사용자 브라우저 | 웹 애플리케이션 서버 |
| **공격 방법** | 악성 스크립트를 삽입하여 사용자의 브라우저에서 실행 | 사용자를 속여 권한이 있는 상태에서 악의적인 요청을 보냄 |
| **피해 범위** | 사용자의 세션 정보 탈취, 악성 코드 실행, 피싱, 웹 페이지 변조 | 사용자의 권한으로 서버에 악의적인 작업 수행 (계좌 이체, 설정 변경 등) |
| **주요 방어 방법** | 입력 검증, 출력 인코딩, 콘텐츠 보안 정책, HTTPOnly 쿠키 | CSRF 토큰 사용, Referer 검사, SameSite 쿠키 설정 |

## XSS는 프론트엔드에서만 막을 수 있나요?
백엔드에서 입력 검증, 출력 인코딩, HTTPOnly 쿠키, 서버 측 필터링 등을 이용해서 막을 수 있다.

1. 입력 검증 (Input Validation)
   * 사용자 입력을 철저히 검증하고, 허용된 형식만 받아들인다.
   * 입력 데이터에서 스크립트 태그 및 특수 문자를 필터링한다.
2. 출력 인코딩 (Output Encoding)
   * 프론트엔드에서만 출력 인코딩을 하지 않고, 백엔드에서도 데이터를 적절하게 인코딩하여 출력한다.
   * 예: 템플릿 엔진에서 제공하는 이스케이프 기능을 사용한다.
3. HTTPOnly 쿠키 사용
   * 세션 쿠키에 HttpOnly 속성을 설정하여, 자바스크립트에서 접근할 수 없도록 한다.
   * 예: Set-Cookie: sessionid=abc123; HttpOnly
4. 서버 측 필터링:
   * 웹 애플리케이션 방화벽(WAF)을 사용하여, 알려진 XSS 공격 패턴을 필터링한다.


