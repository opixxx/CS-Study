# Java & Spring
# 1.JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
### JVM(Java Virtual Machine)
Java를 실행하기 위한 가상 환경이다.
- OS가 ByteCode를 이해할 수 있도록 해석을 도와준다.
- 다양한 플랫폼(CPU + OS)에서 실행 가능하게 해준다.

<img width="317" alt="스크린샷 2025-03-08 오전 8 41 44" src="https://github.com/user-attachments/assets/fd1e3500-070c-45b6-80ef-228e0ef3e3f1" />

클래스 로더가 컴파일된 자바 바이트 코드를 런타임 데이터 영역에 로드하고 실행 엔진이 자바 바이트 코드를 실행한다.
### 클래스 로더
런타임에 클래스를 처음 참조할 때 클래스를 로딩하는 동적 로딩 방식으로 이 부분을 담당하는 부분이 클래스 로더이다.
- 계층 구조 : 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다. 최상위 클래스 로더는 부트스트랩 클래스 로더이다.
- 위임 모델 : 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다. 클래스를 로드할 때 상위 클래스 로더를 확인해서 있으면 해당 클래스를 사용하고 없으면 로드를 요청받은 클래스 로더가 클래스를 로드한다.
- 가시성 제한 : 하위 클래스 로더는 상위 클래스 로더의 클래스를 찾을 수는 있지만, 상위 클래스 로더는 하위 클래스 로더를 찾을 수 없다.
- 언로드 불가 : 클래스 로더는 클래스를 로드할 수 는 있지만 언로드할 수는 없다. 언로드 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성하는 방법을 사용할 수 있다.

![helloworld-1230-2](https://github.com/user-attachments/assets/109699a6-f4b2-415f-9d0c-70626bb41e77)

### 런타임 데이터 영역
JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역

![helloworld-1230-4](https://github.com/user-attachments/assets/ee9dbf92-5cb9-482e-bf61-d65271b8dc8b)

- PC 레지스터 : 현재 수행 중인 JVM 명령의 주소를 갖는다.
- JVM Stack : 각 스레드마다 하나씩 존재한다. 스택 프레임이라는 구조체를 저장하는 스택으로 스택 프레임을 push, pop 동작을 수행한다.
- 네이티브 메서드 스택 : 자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다. 성능향상을 목적으로
- 힙 : 객체 인스턴스를 저장하는 공간, GC의 대상
- 메서드 영역 : 모든 스레드가 공유하는 영역, JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, static 변수, 메서드의 바이트 코드 등을 보관한다.
- 런타임 상수 풀 : 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 래퍼런스까지 담고있는 테이블이다. 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.
### 실행 엔진
클래스 로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트 코드는 실행 엔진에 의해 실행된다.
CPU가 기계 명령어를 하나씩 실행하는 것과 비슷하다.

**인터프리터**
- 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
- 하나씩 해석하고 실행하기 때문에 하나 하나의 해석은 빠르지만 인터프리팅 결과의 실행은 느리다.
- 바이트 코드라는 언어는 기본적으로 인터프리터 방식으로 동작

**JIT 컴파일러**
- 인터프리터 단점을 보완하기 위해 도입된 방법
- 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 네이티브 코드로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식
- 네이티브 코드를 실행하는 것이 인터프리팅 하는 것보다 빠르고, 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행된다.

##  그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
Java와 호환되는 언어 (Kotlin, Scala, Groovy 등)을 실행할 수 있도록 설계되어 있다.

Java 바이트 코드로 변환만 할 수 있다면 다른 언어도 JVM 위에 올릴 수 있다.

## 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
- Kotlin은 Kotlin Native 컴파일러를 사용해서 기계어로 컴파일할 수 있다.
- GraalVM Native Image를 사용해서 네이티브 실행 파일로 컴파일할 수 있다.

## JVM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.

### 장점
- 여러 플랫폼에서 실행할 수 있다.
- 메모리 관리
  - 가비지 컬렉션 : 메모리 할당 및 해제를 자동으로 처리해줘서 메모리 누수와 같은 문제를 신경 안써도 된다.
- JIT 컴파일러를 이용해 자주 실행되는 코드는 최적화

### 단점
- 네이티브 코드 대비 느리다.(클래스 로딩, 바이트코드 해석)
- 하드웨어, 운영체제 최적화된 코드는 작성하기 어렵다

## JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
JVM은 OS 위에서 실행되는 프로그램이다. 내부에서는 스레드라는 개념을 사용하여 동시에 여러 작업을 처리한다. 부모 프로세스 - 자식 프로세스의 관계를 갖는다고는 볼 수 없을 것 같다.

**출처**
- [JVM Internal](https://d2.naver.com/helloworld/1230)

# 2. final 키워드를 사용하면, 어떤 이점이 있나요?
**클래스의 붙일 경우**
- 상속 제한
**메서드의 붙일 경우**
- 오버라이딩 제한
**변수의 붙일 경우**
- 재할당 제한

### 장점
- 코드 안정성을 높인다.
  - 의도치 않은 값의 변경(재할당)을 막는다.
- Thread-safe

##  그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
인라이닝
- final 키워드가 붙으면 컴파일 단계에서 해당하는 값을 이미 알게 된다.
- 변수를 호출하는 대신 실제 값을 호출한다.
- 실제 값에 바로 접근하기 때문에 속도가 빨라진다.

**출처**
- https://stackoverflow.com/questions/4279420/does-use-of-final-keyword-in-java-improve-the-performance
- [\[Java의 이해\] 핫스팟VM의 메소드 인라이닝](https://jangsunjin.tistory.com/191)
- [The Java final Keyword – Impact on Performance](https://www.baeldung.com/java-final-performance)


# 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.

### 추상 클래스
- 추상적인 개념을 제공하는 클래스
- 인스턴스가 존재하지 않는다.
- 상속을 목적으로 사용하고 부모 클래스 역할을 한다.
- 추상 메서드는 상속 받는 자식 클래스에서 반드시 오버라이딩 해서 사용해야한다.

### 인터페이스
- 추상 클래스를 좀 더 편리하게 사용할 수 있는 기능
- 다중 구현을 허용한다.


##  왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
클래스가 단일 상속만 가능한 이유

<img width="652" alt="스크린샷 2024-12-23 오후 3 48 38" src="https://github.com/user-attachments/assets/a2d6aa06-407e-43cb-846b-4cdfe2e76933" />

만약 AirplaneCar 가 Airplane, Car를 다중 상속한다고 가정하자
AirplaneCar 입장에서 move()를 호출할 때 어떤 부모의 move()를 호출해야할지 모르는 문제가 발생한다.
이 문제를 다이아몬드 문제라 한다. 이러한 문제 때문에 자바는 다중 상속을 허용하지 않는다.

그럼 왜 인터페이스는 다중 구현이 가능하냐?
인터페이스는 모두 추상 메서드로 이루어져 있기 때문이다.

<img width="770" alt="스크린샷 2024-12-23 오후 3 51 06" src="https://github.com/user-attachments/assets/d2f7eb5d-2333-4503-97ba-0b79e42cea20" />

- IntefaceA, InterfaceB 모두 methodCommon()을 갖고 있다. 
- Child는 두 인터페이스를 구현한다.
상속 관계일 경우 두 부모 중 어떤 methodCommon()을 사용해야 할지 결정해야하는 문제가 발생한다.
하지만 인터페이스 자신은 구현하지 않는다. 대신 인터페이스를 구현하는 곳에서 해당 기능을 구현해야 한다.
InterfaceA, InterfaceB는 같은 이름의 methodCommon()을 정의하지만 이 메서드는 Child에서 구현한다.
그리고 오버라이딩에 의해 Child에서 구현한 methodCommon()을 호출한다. 그렇기 때문에 다이아몬드 문제가 발생하지 않기때문에 인터페이스는 다중 구현을 허용하는 것이다.

# 4. 리플렉션에 대해 설명해 주세요.
Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고 그 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.

컴파일된 바이트 코드를 통해 Runtime에 동적으로 특정 클래스의 정보를 추출할 수 있는 기법이다.

### 단점
- 컴파일타입 타입 검사가 주는 이점을 하나도 누릴 수 없다.
  - 예외검사도 마찬가지
  - 리플렉션 기능을 써서 존재하지 않거나 접근할 수 없는 메서드를 호출하면(주의해서 대비 코드를 작성하지 않는다면) 런타임 오류가 발생한다.
- 코드가 지저분하고 장황해진다.
- 성능이 떨어진다.
-> 리플렉션을 제한적이고 꼭 필요한 경우에만 사용한다.

## 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?

- 리플렉션을 통해 private 필드나 메서드에 접근할 수 있어 의도치 않게 데이터 노출이나 변경이 될 수 있다.
- 런타임시 java 보안 관리자에게 일부 권한을 부여 받는데 이는 보안 취약점이 될 수 있다.

리플렉션을 통해 private 멤버에 접근할 때 setAccessible(true)를 호출하게 되는 이를 신중하게 사용한다.


## 리플렉션을 언제 활용할 수 있을까요?
- 동적으로 클래스를 사용 해야할 경우
  - Spring Annotation
  - JUnit, Mockito
- 자동 Mapping 기능
  - 인텔리제이
- Jackson
  - 리플렉션을 사용해서 객체 필드의 변수명을 json key에 매핑
 # 5. static class와 static method를 비교해 주세요.
### static class
- 클래스 내부에서 선언된 중첩 클래스
- 외부 클래스와 관련이 있지만 독립적으로 사용 가능
  - 외부 클래스 인스턴스 없이 생성 가능

### static method
- 클래스 내부에 선언된 정적 메서드
- 인스턴스와 관계없는 동작을 수행하거나 유틸리티 기능을 제공
  - 클래스 이름으로 호출 가능

## static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
### 이점

**클래스 수준 공유**
- static 멤버는 모든 객체가 공유한다.
- 객체마다 별도의 인스턴스를 만들 필요 없이, 하나의 멤버를 공유하므로 메모리 효율적이다.

**객체 생성 없이 접근 가능**
- 클래스 이름을 통해 접근할 수 있으므로 객체 생성 하지 않아도 된다.
- 유틸리티 메서드 (Math 클래스)

**초기화가 한 번만 이루어진다.**
- static 필드는 클래스 로드 시점에 한 번만 초기화 되므로 반복적인 초기화를 방지할 수 있다.
- 싱글톤 패턴

### 제약

**인스턴스 멤버 접근 불가**
- static 메서드나 필드는 인스턴스 멤버(non-static 필드나 메서드)에 직접 접근할 수 없다.
```java
class Example { 
	int instanceVar = 10; 
	static int staticVar = 20; 

	static void display() {
	 // System.out.println(instanceVar); // 컴파일 에러
 		System.out.println(staticVar); // static 멤버만 접근 가능 
	}
}
```

**오버라이딩 불가**
- static 메서드는 오버라이딩이 불가
## 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요
1. 자바 컴파일러가 .java -> .class 
2. 컴파일된 .class 파일은 클래스 로더에 의해 JVM의 메모리로 로드된다.
3. static 키워드가 붙은 멤버들은 클래스 로더가 클래스를 로드할 때 메서드 영역에 메모리를 할당받는다.
4. static 변수는 클래스가 로드될 때 초기화된다. 인스턴스 생성 전에 이루어진다.
 # 6. Java의 Exception에 대해 설명해 주세요
### Exception
프로그램 실행 중에 발생할 수 있는 예상치 못한 상황을 처리하기 위한 메커니즘을 제공한다.
-> 프로그램의 안정성과 신뢰성을 높이는 역할

- 예외가 발생하면 잡아서 처리하거나, 처리할 수 없으면 밖으로 던져야 한다.

자바의 예외 처리는 다음 키워드를 사용한다.
`try`, `catch`, `finally`, `throw`, `throws`

<img width="809" alt="스크린샷 2024-12-25 오후 4 05 18" src="https://github.com/user-attachments/assets/7be439be-0cb6-4fac-8095-12c90e9f27a4" />


## 예외처리를 하는 세 방법에 대해 설명해 주세요.
**try-catch**
- 예외가 발생할 수 있는 코드를 try 블록에 작성하고, 예외 발생시 처리를 catch 블록에 작성한다.
- 예외를 감지하면 catch 블록이 실행되고 이후 프로그램은 정상적으로 실행된다.

**throws**
- 메서드 선언부에 throws 키워드를 사용해서 해당 메서드에 발생할 수 있는 예외를 호출한 곳에서 처리하도록 한다.

**사용자 정의**
- 표준 예외 클래스(Exception, RuntimeException)을 상속받아 프로그램의 요구에 맞는 사용자 정의 예외를 생성한다.
```java
public class CustomException extends RuntimeException {
	public CustomException(String message) {
		super(message);
	}
}
```

## CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
### CheckedException
체크 예외는 잡아서 직접 처리하거나 밖으로 던지거나 둘중 하나를 개발자가 직접 명시적으로 처리해야한다.
예외를 잡아서 직접 처리할 수 없을 때 예외를 밖으로 던지는 throws 를 필수로 선언해야 한다. 하지 않으면 컴파일 오류가 발생한다.

**장점**
- 실수로 예외를 누락하지 않도록 컴파일러를 통해 확인할 수 있다.
- 이를 통해 쉽게 어떤 체크 에외가 발생했는지 알 수 있다.
**단점**
- 개발자가 모든 체크 예외를 잡거나 던지도록 처리해야 하기 때문에 너무 번거롭다.

### UncheckedException
언체크 예외는 예외를 잡아서 직접 처리할 수 없을때 throws 를 생략할 수 있다. 선언하지 않으면 알아서 밖으로 던진다. 체크 예외와 다르게 컴파일러가 이런 부분을 체크하지 않는다. 그래서 언체크 예외

**장점**
- 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있다. 체크 예외는 처리할 수 없으면 thorws 를 선언해서 밖으로 던져야 하는데 언체크 예외는 이 부분을 생략할 수 있다.
**단점**
- 개발자가 실수로 예외를 누락할 수 있다. (컴파일러가 확인을 안해주기 때문에)

**처리할 수 없는 예외**
- 상대 네트워크 서버에 문제가 생겨 통신이 불가
- 데이터베이스 서버 문제 발생해서 접속 불가
- 애플리케이션 연결 오류

이렇게 시스템 오류 때문에 발생하는 예외들은 예외를 잡어도 해결할 수 있는 방법이 거의 없다. 예외를 잡아서 다시 호출해도 같은 오류가 발생한다.
이런 경우 오류 페이지를 보여주고 오류에 대한 로그를 남겨둔다.

이렇게 처리할 수 없는 예외가 많아지고, 프로그램이 복잡해지면서 **체크 예외**를 사용하는 것이 부담스러워진다.

**언체크 예외를 사용**
- 처리할 수 없는 예외는 밖으로 던진다.
- 일부 언체크 예외를 잡아서 처리할 수 있따면 잡아서 처리한다.
- 처리할 수 없는 예외들은 공통적으로 처리할 수 있는 곳을 만들어 해결한다.

## 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
### 예외 처리 비용
- 성능에 영향을 미치는 큰 요소는 예외의 발생 경로 trace 이다.
  - fillInstackTrace() 메서드는 call stack을 순회하면서 클래스명, 메서드명, 코드 줄번호 등 정보를 수집해서 stackTrace로 정보를 만들기 때문에 비용이 크게 증가시킨다.
- stack depth에 따라 비용이 더 비싸진다.

### 부하를 줄이는 방법
**fillInstackTrace() 를 오버라이딩 한다.**
NullPointException, OutOfMemory 같은 기본적인 예외말고 우리가 정의한 CustomException 같은 경우는 에러의 추적보다는 다음 비즈니스 로직을 수행하지 못하도록 하는 용도다.
그렇다면 매번 stackTrace를 생성하는 비용은 필요하지 않다. 불필요한 성능 저하를 막기위해 fillInStackTrace()를 오버라이드하여 stackTrace 비용을 줄일 수 있다.
```java
@Override 
public synchronized Throwable fillInStackTrace() {
    return this;
}
```

**Exception을 캐싱한다.**
stackTrace를 생성하지 않도록 오버라이딩한 Exception이면 static final로 선언하여 상수 값 형태로 예외를 캐싱하고 쓰면 매번 같은 종류의 예외를 생성하지 않아도 돼 효율적이다.

**출처**
- [\[Java11\] Exception이 성능에 미치는 영향](https://moonsiri.tistory.com/174)
- [Java Exception 생성 비용은 비싸다. : NHN Cloud Meetup](https://meetup.nhncloud.com/posts/47)
- [Performance Effects of Exceptions in Java](https://www.baeldung.com/java-exceptions-performance)


# 7. Synchronized 키워드에 대해 설명해 주세요.
### Synchronized
여러 스레드가 동시에 접근할 수 있는 자원(객체, 메서드)에 대해 일관성 있고 안전한 접근을 보장하기 위한 메커니즘이다.
- 모든 객체(인스턴스)는 내부에 자신만의 락(모니터 락)을 가지고있다.
- 스레드가 `synchronized` 키워드가 붙은 메서드에 진입하려면 해당 인스턴스의 락이 있어야 한다.

**장점**
- 동기화를 편리하게 사용할 수 있다.
- synchronized 메서드나 블록이 완료되면 자동으로 락을 대기중인 스레드에게 준다.
  - 개발자가 직접 다른 스레드를 안 깨워도 된다.
**단점**
- 무한 대기 -> BLOCKED 상태의 스레드는 락을 획득할 때까지 무한 대기한다.
  - 타임아웃, 중간에 인터럽트 소용없다.
- 공정성 -> BLOCKED 상태의 여러 스레드 중 어떤 스레드가 락을 획득할 지 알 수 없다. 최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있다.
## Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
**메서드 앞에 Synchronized**
- 해당 메서드가 호출될 때 객체의 인스턴스 수준 락을 획득해야 실행된다.
- 즉, 같은 객체에서 이 메서드를 실행하는 스레드가 하나만 존재할 수 있다.
- 다른 객체의 synchronized 메서드와는 별도로 동작한다.

**정적 메서드 앞에 Synchronized**
- 해당 메서드가 호출될 때 클래스 수준 락을 획득해야 실행된다.
- 클래스 전체에서 이 메서드에 대한 동시 호출이 제한된다.
- 같은 클래스와 다른 static synchronized 메서드와도 락을 공유한다.

**블록에 synchronized**
- 지정된 객체에 대한 잠금을 획득해야 블록 내부 코드가 실행된다.
- 동기화 범위를 특정 코드 블록으로 한정할 수 있다.

## 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
vitual thread
무한대기와 공정성에서의 단점이 크다.
단순하고 목적에 맞을 경우에만 사용하는 것을 권장
## Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.

### Lock 인터페이스와 ReentrantLock 구현체
```java
public interface Lock {
     void lock();
     void lockInterruptibly() throws InterruptedException;
     boolean tryLock();
     boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
     void unlock();
     Condition newCondition();
} 
```

`void lock()`
- 락을 획득한다. 
  - 만약 다른 스레드가 이미 락을 획득했다면, 락이 풀릴 때까지 WATING 상태로 있는다. 이 메서드는 인터럽트에 응답하지 않는다.

> 여기서 락은 객체 내부에 있는 모니터 락이 아니다. Lock, ReentrantLock에서 제공하는 기능이다.

`void lockInterruptibly()`
- 락 획득을 하되 다른 스레드가 인터럽트할 수 있도록 한다.
  - 대기 중에 인터럽트가 발생하면 `InterruptedException`이 발생하며 락 획득을 포기한다.

`boolean tryLock()`
- 락 획득을 시도하고, 즉시 성공 여부를 반환한다.
  - 다른 스레드가 이미 락을 획득했으면 false, 그렇지 않으면 락을 획득하고 true

 `boolean tryLock(long time, TimeUnit unit)` 
- 주어진 시간 동안 락 획득을 시도한다.
  - 주어진 시간 동안 락을 획득하면 true, 주어진 시간이 지나도 락을 획득하지 못하면 false
  - 대기 중에 인터럽트가 발생하면 `InterruptedException`이 발생하며 락 획득을 포기한다.

 `void unlock()` 
- 락을 해제한다. 
  - 락을 해제하면 락 획득을 대기 중인 스레드 중 하나가 락을 획득할 수 있게 된다.
  - 락을 획득한 스레드가 호출해야 하며, 그렇지 않으면 `IllegalMonitorStateException` 이 발생할 수 있다. 

`Condition newCondition()` 
- `Condition` 객체를 생성하여 반환한다. `Condition` 객체는 락과 결합되어 사용되며, 스레드가 특정 조건을 기다리거나 신호를 받을 수 있도록 한다. 이는 `Object` 클래스의 `wait` , `notify` , `notifyAll` 메서드와 유사한 역할을 한다.  
ReentrantLock는 공정성 모드와 비공정 모드로 설정할 수 있다.
기본값은 비공정 모드이고, new ReentrantLock(true) 로 하면 공정모드로 설정할 수 있다.

**비공정 모드**
- **성능 우선** -> 락을 획득하는 속도가 빠르다
- **선점 가능** -> 새로운 스레드가 기존 대기 스레드보다 먼저 락을 획득할 수 있다.
- **기아 현상 가능성** -> 특정 스레드가 계속해서 락을 획득하지 못할 수 있다.

**공정 모드**
- **공정성 보장** -> 대기 큐에서 먼저 대기한 스레드가 락을 먼저 획득한다. 
- **기아 현상 방지** -> 모든 스레드가 언젠가 락을 획득할 수 있게 보장된다. 
- **성능 저하** -> 락을 획득하는 속도가 느려질 수 있다. 

Lock 인터페이스와 ReentrantLock 구현체를 사용하면 synchronized 단점인 무한 대기와 공정성 문제를 모두 해결할 수 있다.
## Thread Local에 대해 설명해 주세요.
### ThreadLocal
스레드 별로 독립된 변수를 저장하고 관리하기 위한 Java 클래스다.
동일한 변수라도 각각의 스레드가 고유한 값을 가질 수 있도록 설계되어있어 스레드 간 데이터 공유를 방지한다.

**장점**
- 스레드마다 독립된 값을 사용하기 때문에 동기화가 필요없다.
- Spring Security에서 사용
**단점**
- ThreadLocal 변수는 스레드가 종료될 때까지 제거되지 않아 메모리 누수의 원인이 될 수 있다.
  - 스레드 작업 완료 시 스레드 풀에 반환하기 전에 remove()을 호출해서 ThreadLoacl을 초기화 한다.

# 8. Java Stream에 대해 설명해 주세요.
### Stream
데이터 처리 연산을 지원하도록 소스에서 추출한 연속된 요소
- 연속된 요소 
  - 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
  - 컬렉션의 주제는 데이터고, 스트림의 주제는 계산이다.
- 소스
  - 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.
- 데이터 처리 연산
  - 스트림 연산은 순차적으로 또는 병렬로 실행할 수 있다.

**주요 특징**
- 파이프라이닝
  - 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성하도록 스트림 자신을 반환한다.
- 내부 반복
  - 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.
## Stream과 for ~ loop의 성능 차이를 비교해 주세요.
일반적으로 for-loop가 더 빠르다.
for-loop는 오래전부터 다뤄왔었고, Stream은 비교적 최근에 도입되었다.
그래서 JIT Compiler가 for-loop에 대한 내부 최적화가 잘 되어있다.

**Primitive Type VS Wrapped Type**
Wrapped Type으로 Stream과 for-loop의 성능을 비교하면 성능 차이가 크게 나지 않는다.

Primitive Type 같은 경우 JVM Stack에 값을 저장하기 때문에 직접 참조로 값을 바로 불러올 수 있지만, Wrapped Type은 힙에 저장되어 간접적으로 주소를 가져와서 값을 참조해야 한다.
간접 참조가 직접 참조보다 비용이 훨씬 많이든다. 그 말은 순회를 하는 비용 자체가 높다는 뜻이고, for-loop의 컴파일러 최적화의 이점이 사라진다.

만약 계산 비용이 순회 비용보다 훨씬 높다면 for-loop가 더 이상 Stream보다 성능이 떨어질 수 있다.

**출처**
- https://dogpaw.tistory.com/6
## Stream은 병렬처리 할 수 있나요?

### 병렬 스트림
각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다.
병렬 스트림을 사용하면 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.
병렬 스트림은 내부적으로 ForkJoinPool을 사용한다.

### 주의 사항
- 자동 박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소다. 되도록이면 기본형 특화 스트림(IntStream, LongStream, DoubleStream)을 사용하자
- 순차 스트림보다 병렬 스트림의 성능이 떨어지는 연산이 있다.
  - limit, findFrist 처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하면 비싼 비용이 든다.
- 스트림 전체 파이프라인 연산 비용을 고려하라 
  - 처리해야 할 요소 수가 N이고 하나의 요소를 처리하는 비용이 Q라고 하면 스트림 파이프라인 처리 비용은 N*Q로 예상할 수 있다. Q가 높아진다는 것은 병렬 스트림으로 성능 개선할 가능성이 있음을 의미한다.
- 소량의 데이터는 병렬 스트림이 도움되지 않는다.
- 스트림을 구성하는 자료구조가 적합한지 확인하라
  - ArrayList가 LinkedList보다 적합하다.
  - 분할하려면 LinkedList는 모든 요소를 탐색해야 하지만 ArrayList는 아니다.
- 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 성능이 달라진다.
  - SIZED 스트림을 정확히 같은 크기의 두 스트림으로 분할할 수 있으므로 효과적으로 병렬 처리할 수 있다.
  - filter 연산이 있으면 스트림의 길이를 예측할 수 없어 효과적으로 스트림을 병렬 처리할 수 없다.
- 최종 연산의 병합 과정 비용을 살펴보라
  - 병합 과정이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분결과를 합치는 과정에서 상쇄될 수 있다.
## Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.

### Predicate<T>
입력 값을 받아 true 또는 false를 반환하는 함수형 인터페이스
```java
boolean test(T t);
```
- 필터링 조건을 정의할 때 사용(filter() 메서드)

### Funtion<T, R>
입력 값을 받아 특정 값으로 매핑하는 함수형 인터페이스
```java
R apply(T t);
```
- 데이터 변환 및 매핑 작업(map() 메서드 등)

### Consumer<T>
입력 값을 받아 소비하는 함수형 인터페이스
```java
void accept(T t);
```
- 데이터를 출력하거나 각 요소에 대해 작업을 수행(forEach() 메서드 등)

### Supplier<T>
입력 값 없이 값을 제공하는 함수형 인터페이스
```java
T get();
```
- 값을 생성하거 기본값을 제공

### BiFunction<T, U, R>
두 개의 입력 값을 받아 특정 값으로 매핑
```java
R apply(T t, U u);
```
- 두 입력 값을 조합하여 새로운 값을 생성
```java
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
int result = add.apply(10, 20); 
System.out.println(result);
```

## 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
람다식이나 익명 클래스에서 외부 변수의 값이 변경되면 컴파일 오류가 발생한다. 
- 람다식이나 익명 클래스는 캡쳐된 외부변수를 복사해서 사용한다.
- 만약 외부 변수의 값이 변경되면 복사본과 원본 값이 달라질 수 있다.
- 복사본과 원본의 값이 달라지면 두 값을 동기화 해야하는 멀티스레드 상황에서 이런 동기화는 어렵고, 성능에 나쁜 영향을 줄 수 있다.

그렇기 때문에 외부 변수는 `efficiency final`이어야 한다.

# 9. Java의 GC에 대해 설명해 주세요.
### GC
프로그램이 동적으로 할당했던 메모리 영역 중 필요 없게 된 영역을 알아서 해제하는 것
- 동적을 할당했던 메모리 영역 -> Heap 영역
- 필요 없게 된 영역 -> 어떤 변수도 가리키지 않는 것

<img width="848" alt="스크린샷 2025-03-08 오전 8 54 16" src="https://github.com/user-attachments/assets/41d66080-6522-4c9a-b169-4cc4c54cbe85" />

### Young Generation
- 새롭게 생성되는 객체가 할당되는 영역
- 대부분의 객체가 금방 Unreachable 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라진다.
- Young 영억에 대한 GC를 Minor GC라고 한다.

### Old Generation
- Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
- Young 영역보다 크게 할당되며, GC는 적게 발생한다.
- Old 영역에 대한 GC를 Major GC라고 한다.

### Eden
- 새로 생성된 객체가 위치하는 곳
- 정기적으로 GC 후 살아남은 객체들은 Survivor 영역으로 보낸다.

### Survivor 0 / Survivor 1
- 최소 1번의 GC에서 살아남은 객체가 존재하는 곳
- Survivor 0 또는 Survivor 1 영역 중 한 곳은 비어져 있어야 한다.

### GC 과정
**Minor GC**
1. 처음 생성된 객체는 Eden 영역에 위치
2. Eden 영역이 꽉 차게 되면 Minor GC 실행하고 살아남은 객체는 Survivor 영역으로 이동하고 age을 1증가

**Major GC**
1. 객체의 age가 임계값에 도달하게 되면 Young 영역에 있던 객체들을 Old 영역으로 이동시킨다.(promotion)
2. Old 영역의 공간이 부족하게 되면 Major GC 발생
Major GC는 Minor GC보다 비용이 크다.

## finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?

### finalize()
Object 클래스에 정의되어 있는 메소드이며, GC에 의해 수거될 때 JVM에 의해 자동으로 호출되는 메소드로 수동으로 호출해서는 안되는 메소드이다.

- finalize()는 GC에 의해 호출된다. GC는 JVM이 관리를 하고 언제 GC가 발생하고 어떤 객체가 수거되는지 예측할 수 없다. 따라서 finalize() 호출 시점도 예측할 수 없다.
- 객체가 여전히 참조되고 있음에도 불구하고 리소스를 해제할 수 있다.
- 객체가 정상적으로 GC될 때 다시 finalize()가 호출되지 않을 수 있다.
  - 객체 당 한 번만 호출되기 때문이다.
## 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
root space(Heap, Stack, Method Area)에서 더 이상 도달할 수 없을 때 GC의 대상이 된다.

그렇기 때문에 어떤 변수의 값이 null이 되었다고 해서 그 변수가 다른 변수나 객체에 의해 참조되고 있다면 GC의 대상이 안된다.

GC가 되려면 GC가 수행되는 시점에 root space에 있는 변수 중에 어떤 것도 참조되지 않아야 하낟.

# 10. equals()와 hashcode()에 대해 설명해 주세요.
### equals()
어떤 두 참조 변수의 값의 동등 여부를 비교할 때 사용하는 메서드
> 동일성 : == 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
> 동등성 : equals() 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인

```java
String str1 = "Hello";
String str2 = "Hello";

str1 == str2; // false 주소를 비교하기 때문에
str1.equals(str2); // true 값을 비교하기 때문에
```
- Object가 기본적으로 제공하는 equals()는 == 으로 동일성 비교를 제공한다.
- 동등성의 개념은 각각 클래스마다 다르다. 따라서 동등성 비교를 하고 싶으면 equals()를 재정의해야 한다.

### hashcode()
객체의 주소 값을 이용해서 해싱 기법을 통해 해시 코드를 만든 후 반환하는 메서드
주소값으로 만든 고유한 숫자
- equals 가 두 객체가 같다고 판단하면 hashcode의 값도 같아야 한다.
- Java가 아닌 JVM 네이티브 코드로 구현되었다.

## 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
- equals가 재정의 되었는지 확인한다.
- equals 비교에 사용되는 필드(핵심  필드)에 대해서만 해시코드를 정의한다.
- 32비트 64비트에 따라 해시코드값이 겹칠 수 있다.

## 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
- equals()를 재정의하면 hashcode()도 재정의 하자
# 11. IoC와 DI에 대해 설명해 주세요.
### IoC(Inversion of  Control, 제어의 역전)
프로그램의 제어 흐름을 개발자가 아닌 프레임워크나 컨테이너에게 위임을 한다.
- 결합도 감소 : 객체 간 의존성을 줄이고, 코드의 재사용성과 테스트 용이성을 높인다.
- 유연함 : 객체의 생명주기를 프레임워크에서 처리하므로 애플리케이션 로직에만 집중할 수 있다.
- 확장성 : 객체 관 관계를 쉽게 변경할 수 있어 확장이 용이하다.

### DI(Dependency Injection, 의존성 주입)
객체의 의존관계를 컨테이너에게 위임을 한다.
개발자가 직접 new를 사용해서 의존관계를 만들고 관리하는 방식이 컨테이너가 런타임 시에 의존관계를 주입하는 방식이 된 것이다.(IoC의 구체적인 구현 방식)
- 객체에 필요한 의존성을 스스로 생성하거나 찾지 않고 외부에서 주입받는다.
  - 외부 -> 컨테이너(스프링 컨테이너)
- 의존성이 줄어든다.
- 가독성이 높아진다.
- 재사용성이 높아진다.

### DI 유형
**생성자 주입**
```java
public class A {
	private B b; 
	
	public A(B b) { 
		this.b = b; 
	} 
}
```

**세터 주입**
```java
public class A {
    private B b;
    
    public void setB(B b) {
        this.b = b;
    }
}
```

**인터페이스 주입**
```java
public interface BInjection {
    void inject(B b);
}

public A implements BInjection {
    private B b;
    
    @Override
    public void inject(B b) {
        this.b = b;
    }
}
```

IoC는 객체의 생성과 제어를 개발자 아닌 외부(컨테이너)가 담당하도록 **설계 원칙**
DI는 IoC를 구현하는 방식 중 하나이다. IoC == DI는 아니다.

## 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?

 **인터페이스나 추상 클래스로 추상화 하지 않고 구체 클래스를 그냥 사용하는 경우**
```java
public class EmailService {
	public void sendEmail(Strig mesage) {
		System.out.println("meesage: " + message);
	}
}

public class Application {
	public static void main(String[] args) {
		EmailService emailService = new EmailService();
		emailService.sendEmail("send Email");
	}
}
```
코드가 단순하고 초기 설정 없이 new 키워드로 생성해서 사용 가능하다.
그럼에도 불구하고 Bean을 사용하는 이유가 무엇인가?

**의존성 관리의 일관성**
- Spring에서는 모든 객체를 IoC 컨테이너에서 관리한다. 이 컨테이너가 객체 생성, 의존성 주입, 생명주기 관리를 담당한다.
- 특정 기능을 하는 클래스가 한 개만 존재하더라도 Bean으로 등록해서 컨테이너가 DI를 통해 해당 객체를 관리하게 되어 일관성을 유지할 수 있다.
**테스트 용이성**
- Bean으로 등록하게 되면 테스트 환경에서 Mock,Stub을 주입하기가 용이해진다.

**AOP 적용**
- Spring Bean으로 등록된 객체는 AOP를 적용할 수 있다.
- 나중에 로깅, 트랜잭션 관리, 보안 등의 횡단 관심사를 처리하려면 Bean으로 관리되어야 한다.
## Spring의 Bean 생성 주기에 대해 설명해 주세요.
### Bean
스프링 IoC 컨테이너가 관리하는 객체

1. 스프링 IoC 컨테이너 생성
   - ApplicationContext 구현체로 초기화 된다.
   - 설정 파일(XML, Java Config)이나 컴포넌트 스캔을 통해 Bean 정의를 읽어온다.
2. 스프링 빈 생성
   - IoC 컨테이너가 Bean 정의를 기반으로 Bean을 생성한다.
   - 싱글톤(기본값), 프로토타입(요청할 때마다 새로 객체 생성)
3. 의존관계 주입
4. 초기화 콜백 메소드 호출
   - @PostConstruct, InitializingBean 인터페이스, @Bean(initMethod)등을 사용 
5. 사용
6. 소멸 전 콜백 메소드 호출
   - @PreDestroy, DisposableBean 인터페이스 destroy() 메서드, @Bean(destroyMethod)등을 사용
7. 스프링 종료

**출처**
- [\[spring\] Bean 생성 및 의존관계 형성\(Singleton, 생성자DI와 Immutable Bean\) **](https://jh-labs.tistory.com/31)
## 프로토타입 빈은 무엇인가요?
Bean의 스코프를 정의하는 방법 중 하나이다.
- 요청할 때마다 새로운 인스턴스를 생성하는 스코프이다.
- 프로토타입 빈은 컨테이너가 생성하고 초기화 작업까지만 관리한다.
- @Scope(“prototype”), XML에서 설정

# 12. AOP에 대해 설명해 주세요.

### AOP(Aspect-Oriented Programing, 관점 지향 프로그래밍)
횡단 관심사를 모듈화하여 핵심 기능과 부가 기능(로그, 보안, 트랜잭션 관리 등)을 분리하는 프로그래밍 방법
**Target**
- 부가기능을 부여할 대상
**Advice**
- 타깃에게 제공할 부가기능을 담은 모듈
**Join Point**
- Advice가 적용될 수 있는 위치
**Pointcut**
- Advice를 적용할 조인 포인트를 선별하는 작업
**Advisor**
- 포인트컷과 어드바이스를 하니씩 갖고있는 오브젝트
**Weaving**
- 조인 포인트에 어드바이스를 적용하는 방법

**동작과정**
BeanPostProcessor(빈 후처리기)
- 생성된 빈 객체를 컨테이너에 등록하기전에 조작하는 객체

<img width="949" alt="스크린샷 2024-12-29 오후 9 19 44" src="https://github.com/user-attachments/assets/80ebf440-c5fe-4ff3-8a0a-dccc739b676f" />

1. 빈 객체를 생성한 뒤 빈 후처리기에 전달한다.
2. 어드바지어 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
3. 프록시 생성 대상 빈들을 대상으로 프록시 객체를 생성한다.
4. 프록시를 생성한 빈이라면 프록시 객체를, 프록시를 생성하지 않은 객체이면 그냥 빈을 전달한다.
5. 빈 후처리기에게 전달받은 객체를 컨테이너의 빈으로 등록한다.
## @Aspect는 어떻게 동작하나요?


# 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.
웹과 관련된 공통 관심사는 서블릿 필터나 인터셉터를 사용하는 것이 좋다.
웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL의 정보들이 필요한데 서블릿 필터, 인터셉터는 HttpServletRequest를 제공한다.

### Servlet Filter
디스패처 서블릿에 요청이 전달되기 전/후에 URL 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공한다. 

**필터 흐름**
`HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러`
필터를 적용하면 필터가 호출된 후 서블릿이 호출된다. 

**필터 제한**
```
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 //로그인 사용자
HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이면 서블릿 호출 X) //비 로그인
```
필터에서 적절하지 않은 요청이라고 판단하면 서블릿을 호출하지 않고 끝낸다.

**필터 체인**
`HTTP 요청 -> WAS -> 필터1 -> 필터2 -> 필터3 -> 서블릿 -> 컨트롤러` 
필터는 체인을 구성되며, 중간에 필터를 자유롭게 추가할 수 있다. (로그를 먼저 남기는 필터 후 로그인 여부를 체크하는 필터를 만들 수 있음)

필터 인터페이스를 구현하고 등록하면 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고 관리한다.
- init() : 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다.
- doFilter() : 요청이 올 때 마다 해당 메서드가 호출된다. 필터의 로직을 구현하는 곳
- destroy() : 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.


### Interceptor
Spring이 제공하는 기술로써, 디스패처 서블릿이 컨트롤러를 호출하기 전/후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공한다.

**스프링 인터셉터 흐름**
`HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러`
- 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출된다.
- 스프링 인터셉터에도 URL 패턴을 적용할 수 있다. 서블릿 URL 패턴과는 다르고 매우 정밀하게 설정할 수 있다.
**스프링 인터셉터 제한**
```
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러 //로그인 사용자 HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터(적절하지 않은 요청이면, 컨트롤러 호출 X) // 비 로그인 사용자 
```

**스프링 인터셉터 체인** 
`HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터1 -> 인터셉터2 -> 컨트롤러` 
스프링 인터셉터는 체인으로 구성되며, 중간에 인터셉터를 자유롭게 추가할 수 있다.

스프링 인터셉터를 사용하려면 `HandlerInterceptor` 인터페이스를 구현하면 된다.

서블릿 필터는 doFilter() 하나만 제공된다. 인터셉터는 컨트롤러 호출 전(preHandler), 호출 후(postHandler), 요청 완료 이후(afterCompletion)으로 단계적으로 세분화 되어 있다.

**스프링 인터셉터 호출 흐름**

<img width="1091" alt="스크린샷 2025-03-08 오전 8 56 50" src="https://github.com/user-attachments/assets/1b929b58-2576-43da-b0a7-a9b15ebb3abf" />

- preHandler : 컨트롤러 호출 전에 호출된다.(더 정확히는 핸들러 어댑터 호출 전에 호출된다.)
  - preHandler의 값이 true면 다음으로 진행, false이면 더 이상 진행하지 않는다.
  - false인 경우 나머지 인터셉터, 핸들러 어댑터도 호출하지 않는다. 1번에서 끝난다.
- postHandler : 컨트롤러 호출 후 호출된다. 
- afterCompletion : 뷰가 렌더링 된 이후에 호출된다.

**컨트롤러에서 예외가 발생 시** 
- preHandler : 컨트롤러 호출 전에 호출되기 때문에 호출된다.
- postHandler : 컨트롤러에서 예외가 발생하면 postHandler는 호출되지 않는다.
- afterCompletion : 항상 호출된다. 예외를 파라미터로 받아서 어떤 예외가 발생했는지 로그로 출력할 수 있다.
  - 예외가 발생해도 항상 호출되기 때문에 예외와 무관하게 공통으로 처리를 하고 싶으면 afterCompletion을 사용하면 된다.
  
## 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?

필터는 서블릿 컨테이너에서 관리되기 떄문에 스프링과 무관하게 처리해야하는 작업들을 처리할 수 있다.
- 공통된 보안 및 인증/인가 작업
  - XSS 방어
- 이미지/데이터 압축 및 문자열 인코딩
- 모든 요청에 대한 로깅 작업
- 다음 체인으로 넘기는 ServletRequest/ServletResponse를 변경해서 넘겨야 할 경우
  - 그런 경우가 뭐가 있을까?
  - 스프링 시큐리티를 생각해보면 좋을 듯? 쿠키같은 헤더를 만지는 작업(읽거나 응답 객체 헤더에는 추가할 수 있지만 body를 변경하거 조작할 순 없다)
# 14. DispatcherServlet 의 역할에 대해 설명해 주세요.
### DispatcherServlet
HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적절한 컨트롤러에 위임해주는 역할을 한다.
HTTP 요청 -> WAS -> 서블릿 컨테이너 -> 디스패처 서블릿

<img width="1066" alt="스크린샷 2025-03-08 오전 8 57 51" src="https://github.com/user-attachments/assets/87914732-a6c4-4ac1-8a75-368ba6f3f78f" />

**동작 순서**
1. 핸들러 조회 : 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.
   - 최근에는 `@Controller`에 `@RequestMapping` 관련 어노테이션을 사용해 컨트롤러를 작성하는 것이 일반적이다.
   - 이런 방식은 `RequestMappingHandlerMapping`이 처리한다.
2. 핸들러 어댑터 조회 : 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
3. 핸들러 어댑터 실행 : 핸들러 어댑터를 실행한다.
   - @RequestParam, @RequestBody 등을 처리하기 위한 ArgumentResolver
   - ResponseEntity의 Body를 Json으로 직렬화하는 등의 처리를 하는 ReturnValueHandler
4. 핸들러 실행 : 핸들러 어댑터가 실제 핸들러를 실행한다.
5. 컨트롤러가 반환값을 반환
   - 응답 데이터를 사용하는 경우 ResponseEntity 반환
   - 응답 페이지를 보여주는 경우 String으로 View 이름을 반환
6. 핸들러 어댑터가 반환값을 처리
   - 컨트롤러로부터 받은 응답을 ReturnValueHandler가 후처리한 후 디스패처 서블릿으로 돌려준다.
   - ResponseEntity를 반환하면 HttpEntityMetodProcessor가 MessageConverter를 사용해 응답 객체를 직렬화하고 응답 상태를 설정
   - View 이름을 반환하면 ViewResolver를 통해 View 반환
7. 서버의 응답을 클라이언트로 반환
   - 디스패처 서블릿을 통해 반환되는 응답은 다시 필터를 거쳐 클라이언트로 반환
   - 응답이 데이터라면 그대로 반환, 응답이 화면이라면 View 이름에 맞는 View를 찾아서 ViewResolver가 적절한 화면을 내려준다.

## 여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?
요청이 들어왔을 때의 서블릿의 동작이다.
1. WAS의 서블릿 컨테이너가 서블릿 객체를 로드 및 초기화(init() 호출)
2. 클라이언트의 HTTP 요청을 WAS가 수신
3. HttpServletRequet, HttpServletResonse 객체 생성
4. 별도의 스레드가 서블릿의 service() 메서드 호출
5. HttpServletResponse를 통해 결과를 클라이언트에 반환
6. 사용된 request, response 객체는 제거되고 스레드 반환

WAS는 스레드 풀을 관리하고 있다. 그래서 여러 HTTP 요청을 별도의 스레드에서 처리한다.
그렇기 때문에 디스패처 서블릿은 멀티 스레드를 통해 여러 요청을 처리할 수 있다.
> 디스패처 서블릿은 싱글톤으로 관리된다.
> 여러 요청은 같은 디스패처 서블릿의 인스턴스가 처리한다.

## 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?

RequestMappingHandlerMapping이 @Controller, @RequestMapping가 클래스 레벨에 붙어 있는 경우에 매핑 정보로 인식한다.

클라이언트가 `http://example.com/hello`를 요청한 경우
```java
@Controller
public class MyController {
	@RequestMappin("/hello)
	public String hello() {
		return "hello";
	}
}
```

1. 디스패처 서블릿은 URL `/hello`를 기반으로 적절한 컨트롤러를 찾기위해 HandlerMapping을 호출
   - RequestMappingHandlerMapping은 /hello -> MyController.hello()로 매핑된 정보를 반환
2. HadlerAdaper 실행
   - 디스패처 서블릿은 MyController.hello()를 실행하기 위해 적절한 HandlerAdapter를 선택한다.
   - RequestMappingHandlerAdapter가 호출되어 컨트롤러 메서드를 실행
3. 응답을 처리한다.

# 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

### ORM(Object Relational Mapping)
객체와 DB 테이블을 매핑 시켜 RDB 테이블을 객체지향적으로 사용할 수 있게 해주는 기술

### ORM을 사용하는 이유
객체 지향 : 추상화, 상속, 다형성
데이터베이스 : 데이터 중심으로 구조화, 집합적인 사고
이 두가지가 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다. 
-> 이것을 패러다임의 불일치 문제라고 한다.

이런 문제를 해결하는 데 중간에서 개발자가 많은 시간과 코드를 소비해야 한다. 
ORM이 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지할 수 있게 도와준다.

## 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
### 영속성 컨텍스트
- 엔티티를 영구 저장하는 곳
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 역할
- 엔티티 매니저를 통해서 엔티티를 저장하고 조회한다. 

**장점**
- 1차 캐시
  - 키는 식별자 값(기본키), 값은 엔티티 인스턴스
  - 1차 캐시에 값이 있으면 1차 캐시에서 조회, 없다면 데이터베이스 조회
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
  - 쿼리를 바로 데이터베이스에 보내지 않고 1차 캐시에 저장
  - 내부 쿼리 저장소에 저장
  - 트랜잭션을 커밋하는 순간 저장된 쿼리를 데이터베이스 보냄
- 변경 감지
- 지연 로딩

## N + 1 문제에 대해 설명해 주세요.

### N + 1
- 회원 하나 당 여러 개의 주문을 한다
- 회원을 조회하는 쿼리를 날리면 연관된 주문을 조회하는 쿼리도 날아간다.
- 조회한 회원이 3명이면 3명과 관련된 주문을 조회하기 위해 3개의 쿼리가 날아간다.

**해결**
- 페치 조인을 사용해서 연관 데이터를 한 번의 쿼리로 가져오는 방법
- default_batch_fetch_size 를 설정해서 컬렉션이나 프록시 객체를 설정한 size만큼 IN 쿼리로 조회한다.


# 16. @Transactional 은 어떤 기능을 하나요?
트랜잭션 코드와 비즈니스 로직의 혼합을 피하기 위해 Spring AOP를 통해 트랜잭션을 처리한다.

### 동작과정

![image](https://github.com/user-attachments/assets/152c2597-0ac0-42a3-b645-1d732314f6ca)

1. 트랜잭션을 시작하려면 커넥션이 필요하다. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관한다.
3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 따라서 파라미터로 커넥션을 전달하지 않아도 된다.
4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.

## @Transactional(readOnly=true) 는 어떤 기능인가요? 이게 도움이 되나요?
트랜잭션을 읽기 전용 모드로 설정하는 기능이다.

- 스프링 프레임워크가 하이버네이트 세션의 플러시 모드를 `MANUAL`로 설정한다.
- 강제로 플러시를 호출하지 않는 한 플러시가 일어나지 않는다.
- 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시를 하지 않는다.
- 그렇기 때문에 등록, 수정, 삭제가 일어나지 않는다.
  - 스냅샷 비교와 같은 무거운 로직들이 수행하지 않기 때문에 성능이 향상된다.

## 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?

- 트랜잭션 내에서 동일한 읽기 결과가 필요할 때
- 읽기 작업만 하더라도 트랜잭션을 걸어주는게 좋다. 트랜잭션을 걸지 않으면 모든 SELECT 쿼리마다 commit을 하기 때문에 성능이 떨어진다.

**출처**
- [springframework:transaction \[권남\]](https://kwonnam.pe.kr/wiki/springframework/transaction)

### 단순한 읽기 작업일 경우
트랜잭션을 안 붙히는 이유
- 커넥션을 오래 들고 있지 않아서 성능적으로 유리하다.
- AOP를 처리를 위한 오버헤드
트랜잭션을 붙여야 한다.
- 트랜잭션을 걸지 않으면 모든 SELECT 쿼리마다 commit을 하기 때문에 성능이 떨어진다.

# Java에서 Annotation은 어떤 기능을 하나요?
### Annotation
- 소스 코드에 추가적인 정보를 제공하는 메타 데이터의 기능을 수행한다.
- 비즈니스 로직에 직접적으로 영향을 주지 않는다.
- 클래스 또는 인터페이스 등을 컴파일하거나 실행할 때 어떻게 처리해야 할 것인지를 알려주는 설정 정보
- 클래스, 메소드, 변수, 인자 등에 추가할 수 있다.

**Annotation 용도**
- 컴파일 시 사용하는 정보 전달(ex. @Override)
- 빌드 툴이 코드를 자동으로 생성할 때 정보 전달(ex. @Data)
- 런타임 시 특정 기능을 처리할 때 사용하는 정보 전달(ex. @Autowired)

**Meta 어노테이션**
다른 Annotation에 적용되기 위한 Annotation

- @Target : 해당 Annotation이 사용될 수 있는 위치를 선정
- @Retention : 해당 Annotation의 정보를 어느 범위까지 유지할 것인지 설정
- @Documented : 해당 Annotation에 대한 정보를 javadocs에 포함시킴
- @Inherited : 해당 Annotation의 상속을 가능하게 함
- @Repeatable : 해당 Annotation을 여러 번 선언할 수 있게 함

## 별 기능이 없는 것 같은데, 어떻게 Spring에서는 Annotation이 그렇게 많은 기능을 하는 걸까요?
리플렉션을 활용해서 Annotation을 처리한다.
- 리플렉션을 통해 클래스, 메서드, 필드, 파라미터에 선언된 어노테이션을 확인한다.
- 원하는 어노테이션이 붙어있으면 해당 로직을 수행한다.
  - @Autowired가 있는 필드를 찾아서 타입에 맞는 빈을 자동으로 주입한다.
AOP
- AOP를 통해 어노테이션이 적용된 코드에 부가 기능을 추가할 수 있다.
## Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?

### @Data
@ToString, @Getter, @Setter, @EqualsAndHashCode, @RequiredArgsConstructor을 한 번에 사용하는 어노테이션

- @Setter 사용 지양
- 순환 참조시 @ToString으로 인한 무한 순환 참조 발생
- Mutable 객체에 아무런 파라미터 없이 그냥 사용하는 @EqualsAndHashCode

**출처**
- [java:lombok:pitfall \[권남\]](https://kwonnam.pe.kr/wiki/java/lombok/pitfall)

# 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

### Tomcat
Java 웹 어플리케이션을 실행하기 위한 서블릿 컨테이너이며 WAS이다.

**서블릿 컨테이너**
- Java Servlet, JSP, WebSocket 등의 Java 기술 사양을 구현하여 실행 환경을 제공한다.
- HTTP 요청 및 응답
- 서블릿 관리 : 서블릿 객체를 생성, 초기화, 실행, 소멸
- JSP 처리 : JSP 파일을 서블릿으로 변환하고 실행

## 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?
기존 소켓 통신 프로그래밍은 동기적인 네트워트 통신어서 문맥교환과 관련된 문제와 입력 출력 데이터에 관련한 무한 대기 현상이 발생하는 문제가 있었다. 이 문제를 해결하기 위해 비동기적인 네트워크 통신을 하는 NIO가 개발됐다.

Netty는 NIO 클라이언트 서버 프레임워크로서 NIO 방식의 네트워크 프로그래밍을 크게 단순화하고 간소화한다.

**출처**
- https://velog.io/@monami/Netty
- [Netty란?](https://narup.tistory.com/118#google_vignette)
