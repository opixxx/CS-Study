# 가상 메모리
실제 물리 메모리 크기보다 큰 메모리 공간을 프로그램에 제공하는 기술이다. 
이를 통해 프로그램은 사용 가능한 실제 메모리보다 더 많은 메모리를 사용하는 것처럼 동작할 수 있다.

## 등장 배경
- 과거에는 물리 메모리만 사용했기 때문에 프로그램의 크기가 RAM을 초과하면 실행할 수 없었다. 프로그램이 점점 커지고, 동시에 여러 프로그램을 실행해야 하는 상황이 늘어나면서 메모리 확장 필요해졌다.
- 예전에는 프로세스를 실제 물리 메모리에 매핑했기 때문에 해당 프로세스가 어떤 문제가 생겨 죽게되면 OS는 어떤 메모리를 회수해야하는지 알기 어려웠다. 이로 인해 메모리 낭비도 생기고, 시스템 전체(OS)도 장애가 나게된다. 

이를 해결하기 위해 CPU가 직접 물리 메모리를 참조하는 것이 아니라, 가상 주소를 통해 메모리에 접근하고, OS가 이를 물리 주소로 변환하여 관리하는 가상 메모리 기술이 등장했다.

## 요구 페이징
프로그램 실행 중 필요할 때만 페이지가 적재된다. 따라서 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다. 이를 통해 메모리를 더 효율적으로 사용한다.

<img width="829" alt="스크린샷 2025-02-15 오후 9 33 16" src="https://github.com/user-attachments/assets/81d2e161-a453-4bc1-bf79-f32eeb24f04e" />

메모리를 페이지 단위로 나누고 페이지 테이블을 통해 물리 메모리에 매핑을 한다. 필요한 페이지만 물리 메모리에 올리고, swap을 통해 나머지는 하드디스크에 저장한다.

## Page Fault가 발생하면?

그전에 페이지 테이블 엔트리 구성을 보자

### 페이지 테이블 엔트리

<img width="618" alt="스크린샷 2024-11-11 오후 3 07 26" src="https://github.com/user-attachments/assets/111e9ca8-c9c7-4ab9-9516-cad940ccff0c" />

- access bit : 페이지에 접근이 이루어졌는지를 나타내는 비트
- modified(dirty) bit : 페이지가 수정되었는지를 나타내는 비트
- valid bit : 페이지가 유효한 메모리 영역에 할당되었는지 여부를 나타내는 비트
- read bit: 해당 페이지가 읽기 권환이 있는지를 나타내는 비트
- write bit : 해당 페이지가 쓰기 권환이 있는지를 나타내는 비트
- excute bit : 해당 페이지가 실행 권환이 있는지를 나타내는 비트이다.

**modified bit**
만약 modified bit가 1이면 수정이 됐다는 것을 의미하기 때문에 하드 디스크에 swap out 될 때 쓰기 작업을 해줘야 한다.

**valid bit**
해당 페이지가 물리 메모리에 올라와 있는지 안 올라왔는지를 나타내는 비트이고, 비트가 0이라면 Page Fault 인터럽트를 발생시킨다.

### Page Fault
Page Fault란 유효 비트가 0인 공간(=페이지에 메모리가 적재되지 않음)에 접근하려고 할 때 발생하는 인터럽트이다.

![img1 daumcdn](https://github.com/user-attachments/assets/c5f00d9e-8975-44f2-ba68-ea4e397cc3ca)

1. 페이지 테이블을 통해 필요한 페이지가 유효한지 검사한다.
2. 만약 invalid한 페이지에 대한 참조라면 그 프로세스는 중단된다. 만약 valid한 페이지가 아직 메모리에 올라오지 않았다면, 그것을 보조저장장치로부터 가져와야한다.
3. 빈 공간, 즉 가용 프레임을 찾는다
4. 보조저장장치에 새로 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청한다.
5. 보조저장장치에 읽기가 끝나면, 이 페이지가 이제는 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신하며, 프로세스가 유지하고 있는 내부 테이블을 수정한다.
6. 트랩에 의해 중단되었던 명령어를 다시 수행한다.

