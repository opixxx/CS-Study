# [MYSQL] 트랜잭션 격리수준

## 트랜잭션 격리 수준(Transaction Isolation Level)
트랜잭션의 격리 수준이란 ***여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것***이다.

트랜잭션의 격리 수준은 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`로 나뉜다.

순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리(고립) 정도가 높아지며, 동시 처리 성능도 떨어지는 것이 일반적이라고 볼 수 있다.

## READ UNCOMMITTED
각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.

![IMG_59405EF53079-1](https://github.com/user-attachments/assets/f9f62e97-256b-447b-90b5-817dafa9e350)

- 사용자 A가 새로운 데이터를 INSERT를 했다.
- 사용자 B가 변경된 내용을 커밋하기도 전에 INSERT한 데이터를 조회할 수 있다.
여기서 생기는 문제가 있다.
만약 사용자 A가 어떤 문제가 발생해 INSERT 한 데이터를 롤백하더라도 여전히 사용자 B는 조회한 데이터를 정상적인 데이터라고 판단하고 계속 처리할 것이다.

이처럼 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 DIRTY READ라 한다. READ UNCOMMITTED는 DIRTY READ를 허용하는 격리 수준이다.

## READ COMMITTED
어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다. 그렇기 때문에 이 레벨에서는 DIRTY READ와 같은 현상은 발생하지 않는다.

![JPEG 이미지-453E-907D-62-0](https://github.com/user-attachments/assets/679f0337-6b94-4966-86f8-fde0fa1025a9)

- 사용자 A가 특정 데이터를 변경했다.
- 이 때 새로운 값은 테이블에 즉시 기록되고 이전 값은 언두 영역으로 백업된다.
- 사용자 A가 커밋을 수행하기 전에 사용자 B는 언두 영역에 백업된 레코드에서 가져온다.
- 사용자 A가 최종적으로 변경된 내용을 커밋하면 그때부터는 다른 트랜잭션에서도 새롭게 변경된 값을 참조할 수 있게 된다.

하지만 READ COMMITTED 에서는 NON-REPEATABLE READ라는 문제가 있다.

![IMG_8476B249E432-1](https://github.com/user-attachments/assets/843f2465-d129-4b41-a19a-d6cf41e37d1b)

- 사용자 B가 트랜잭션을 시작하고 first_name이 “Toto”인 사용자를 검색했는데, 일치하는 결과가 없었다.
- 하지만 사용자 A가  사원 번호가 500000인 사원의 이름을 "Toto”로 변경하고 커밋을 실행한 후, 사용자 B가 똑같은 SELECT 쿼리로 다시 조회하면 결과가 1건이 조회된다.

이는 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋나는 것이다.

예를 들어 어떤 트랜잭션에서는 오늘 입금된 총 합을 계산하고 있는데, 다른 트랜잭션에서 계속해서 입금 내역을 커밋하는 상황이라고 하자. 그러면 READ COMMITTED에서는 같은 트랜잭션일지라도 조회할 때마다 입금된 내역이 달라지므로 문제가 생길 수 있는 것이다.

## REPEATABLE READ
MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다. 
- 이 격리 수준에서는 NON-REPEATABLE READ 문제가 발생하지 않는다. 
- 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경한다. 이러한 방식을 MVCC(Multi Version Concurrency Control)라고 한다.
- MVCC를 통해 트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있다.
- 각각의 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재하며, 언두 영역에 백업된 모든 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장한다.
- 언두 영역의 백업된 데이터가 불필요하다고 판단하는 시점에 주기적으로 삭제한다.

![JPEG 이미지-477D-935F-93-0](https://github.com/user-attachments/assets/5b175866-d04c-4c81-810b-23bbaec2945a)

- employees 테이블은 번호가 6인 트랜잭션에 의해 INSERT 됐다고 가정하자.
- 사용자 B가 emp_no가 500000을 조회하면 1건이 조회됐다고 가정하자.
- 사용자 A가 emp_no가 500000인 사원의 이름을 “Toto”로 변경했다.
  - MVCC를 통해 기존 데이터는 변경되지만 백업된 데이터가 언두 로그에 남게 된다.
- 사용자 B가 데이터를 조회했던 트랜잭션은 아직 종료되지 않은 상황에서, 사용자 B가 다시 동일한 SELECT 문을 실행한다.
  - 사용자 B의 트랜잭션(10)은 사용자 A의 트랜잭션(12)이 시작하기 전에 이미 시작된 상태다.
  - 그때부터 사용자 B 트랜잭션 안에서 실행되는 모든 SELECT 쿼리는 트랜잭션 번호 10보다 작은 트랜잭션 번호에서 변경한 것만 보게 된다.
  - 테이블에 자신보다 이후에 실행된 트랜잭션의 데이터가 존재한다면 언두 로그를 참고해서 데이터를 조회한다.
- REPEATABLE READ는 어떤 트랜잭션이 읽은 데이터를 다른 트랜잭션이 수정하더라도 동일한 결과를 반환할 것을 보장한다.

REPEATABLE READ는 새로운 레코드의 추가까지는 막지 않는다. 따라서 SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데 이른 PHANTOM READ라고 한다. 
![IMG_699C335A648D-1](https://github.com/user-attachments/assets/862c7bb3-a3b4-4961-9ae9-849fe2531586)

### 일반적인 RDBMS 경우
- 일반적인 DBMS에는 갭락이 존재하지 않으므로 emp_no = 500000 인 레코드만 잠금이 걸린 상태이므로 사용자 A의 요청은 잠금 없이 즉시 실행된다.
- 이때 사용자 B가 동일한 SELECT FOR UPDATE로 데이터를 조회하면 이번에는 2건의 데이터가 조회된다. 
동일한 트랜잭션 내에서도 새로운 레코드가 추가되는 경우에 조회 결과가 달라지는데 이러한 문제를 PHANTOM READ라고 한다. 이는 다른 트랜잭션에서 새로운 레코드를 추가하거나 삭제하는 경우에 발생한다.

MVCC를 통해 해결될 것 같지만 두 번째 SELECT FOR UPDATE 때문에 해결할 수 없다. SELECT FOR UPDATE는 SELECT 하는 레코드에 쓰기 잠금을 걸어야하는데, 언두 레코드에는 잠금을 걸 수 없다. 따라서 SELECT FOR UPDATE, SELECT LOCK IN SHARE MODE로 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는게 아니라 테이블의 레코드를 가져오게 되므로 PHANTOM READ가 발생하는 것이다.

### MySQL 경우
- MySQL에는 갭 락이 존재하기 때문에 위의 상황에서 문제가 발생하지 않는다.
- 사용자 B가 SELECT FOR UPDATE로 데이터를 조회한 경우에 MySQL은 emp_no가 500000인 레코드에는 레코드 락, 500000보다 큰 범위에는 갭 락으로 넥스트 키 락을 건다. 
- 따라서 사용자 A가 emp_no 500001인 데이터를 INSERT 시도하여도 B의 트랜잭션이 종료될 때까지 기다린다.
이 때문에 일반적으로 MySQL REPEATABLE READ에서는 PHANDOM READ가 발생하지 않는다.

## SERIALIZABLE
가장 엄격한 격리 수준으로 트랜잭션을 순차적으로 진행시킨다. InnoDB 테이블에서 기본적으로 순수한 SELECT 작업은 아무러 레코드 잠금도 설정하지 않고 실행한다. 하지만 SERIALIZABLE로 격리 수준을 설정하면 순수한 SELECT 작업에서도 대상 레코드에 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
SERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지므로 거의 사용하지 않는다.
