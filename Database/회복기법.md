# 데이터베이스 시스템 장애를 복구하기 위한 방법

트랜잭션의 Durability를 보장하기 위해서는 시스템 장애가 발생했을 때 데이터베이스를 원래 상태로 복구하는 회복 기능이 필요하다.

덤프나 로그 방법을 사용해서 데이터를 복사해두었다가 회복시킬 때 복사본을 사용한다.

### 덤프
- 데이터베이스 전체를 별도의 저장 장치에 주기적으로 복사하는 방법
- 미리 정해진 주기에 따라 수행된다.
- 디스크와 같은 비휘발성 장치에 저장한다.

### 로그
- 데이터베이스에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법

덤프나 로그 방법으로 데이터를 복구하는 가장 기본적인 방법은 **redo**, **undo** 연산을 실행하는 것이다.

redo : 가장 최근에 저장한 데이터베이스 복사본을 가져온 후 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 데이터베이스 상태로 복구
-> 전반적으로 손상된 경우에 주로 사용

undo : 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 데이터베이스를 원래의 상태로 복구
-> 변경 중이었거나 이미 변경된 내용만 신뢰성을 잃은 경우에 주로 사용


## 로그 회복 기법

<img width="480" alt="스크린샷 2025-02-26 오전 12 24 36" src="https://github.com/user-attachments/assets/c05f7f08-5bbd-4723-b0f7-355cd1541b4c" />

### 즉시 갱신 회복 기법
트랜잭션 수행 중에 데이터를 변경한 연산의 결과를 데이터베이스에 즉시 반영한다.

<img width="802" alt="스크린샷 2025-02-26 오전 12 28 13" src="https://github.com/user-attachments/assets/1512a180-55c2-44f0-ab17-4aa59f878950" />

**1번 시점에 장애가 발생했을 때**
- 1번 시점에는 T1이 수행이 아직 완료되기 전이므로 로그 파일에 <T1, start> 로그 레코드만 존재하고 <T1, commit>이 존재하지 않는다.
- T1 트랜잭션에 undo(T1) 연산을 실행해야 한다.
  - 지금까지 변경한 데이터의 값을 변경 연산 이전의 값으로 되돌려야 한다.
- A 계좌의 변경 이전 값인 5000원으로 되돌아간다.

**2번 시점에 장애가 발생했을 때**
- T1은 수행이 이미 완료되었으므로 로그 파일에 <T1, start>,<T1, commit> 모두 존재한다.
- T2는 수행이 아직 완료되기 전이므로  로그 파일에 <T1, start> 로그 레코드만 존재하고 <T1, commit>이 존재하지 않는다.
- T1 트랜잭션에는 redo(T1) 연산, T2에는 undo(T2) 연산을 실행해야 한다.
  - 회복을 위해 두 연산이 모두 필요할 때는 undo, redo 순서로 실행한다.
- T2에서 undo연산을 하게되면 C 계좌의 값을 3000원으로 되돌린다.
- T1에서 redo 연산을 하게되면 A 계좌의 값이 변경 이후의 값 4000원, B 계좌의 값이 변경 이후의 값 1000원이 된다. 
  - redo 연산이 필요한 데이터가 여러 개인 경우에는 로그에 기록된 순서대로 redo 연산을 실행한다.


### 지연 갱신 회복 기법
트랜잭션이 수행되는 동안에는 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영하지 않고 로그 파일에 기록해두었다가, 트랜잭션이 부분 완료된 후에 로그에 기록된 내용을 이용해 데이터베이스에 한 번에 반영

<img width="824" alt="스크린샷 2025-02-26 오전 12 28 24" src="https://github.com/user-attachments/assets/bdeacfde-e9ab-4f54-838e-c6f11c91227f" />

**1번 시점에 장애가 발생했을 때**
- 1번 시점에는 T1이 수행이 아직 완료되기 전이므로 로그 파일에 <T1, start> 로그 레코드만 존재하고 <T1, commit>이 존재하지 않는다.
- 연산 결과를 데이터 베이스에 저장하기 전이므로 로그에 기록된 내용만 버리면 다른 회복 조치를 하지 않아도 된다. 트랜잭션의 수행을 다시 시작하기만 하면 된다.
**2번 시점에 장애가 발생했을 때**
- T1은 <T1, start>, <T1, commit> 모두 존재하기 떄문에 redo(T1) 연산을 한다.
- 변경 이후의 값인 A 계좌 4000원 B 계좌 1000원이 된다.
- T2는 <T1, start>만 존재한다. 로그에 기록된 내용을 버리고 다른 회복 조치를 하지 않는다.

### 검사 시점 회복 기법
로그를 이용한 회복 기법은 로그 전체를 분석하여 로그에 기록된 모든 트랜잭션을 대상으로 redo나 undo 중에서 적용할 회복 연산을 결정해야 된다. 그런데 로그 전체를 대상으로 회복 기법을 적용하면 데이터베이스 회복에 너무 많은 시간이 걸리고 redo 연산을 수행할 필요가 없는 트랜잭션에도 redo 연산을 실행하는 일이 발생하기도 한다.
로그 회복 기법과 같은 방법으로 로그 기록을 이용하되, 일정 시간 간격으로 검사 시점(checkpoint)을 만들어둔다. 그리고 장애가 발생하면 가장 최근 검사 시점 이전의 트랜잭션에는 회복 작업을 수행하지 않고, 이후의 트랜잭션에만 회복 작업을 수행한다.

### 미디어 회복 기법
전체 데이터베이스의 내용을 일정 주기마다 다른 안전한 저장 장치에 복사해두는 덤프를 이용한다.
디스크 장애가 발생하면 가장 최근에 복사해둔 덤프를 이용해 장애 발생 이전의 일관된 데이터베이스 상태로 복구한다. 그런 다음 필요에 따라 로그의 내용을 토대로 redo 연산을 실행한다.
 전체 데이터베이스를 다른 저장 장치에 복사하는 것은 비용이 많이 들고 복사하는 동안에 트랜잭션 수행을 중단해야 하므로 미디어 회복 기법은 CPU가 낭비된다는 단점이 있다.
