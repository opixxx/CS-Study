# 명령어 파이프라인 구조
- 하나의 명령어 사이클을 여러 단계로 나누고 각 단계에서 동시에 다른 명령어를 처리하도록 CPU 설계 
  - 이러한 작업을 파이프라이닝(pipelining)
- 파이프라인의 깊이는 총 단계 수
  - 각 단계는 독립적인 모듈로 구성되어 서로 다른 명령어를 다른 단계에서 동시에 처리하도록 설계
## 2단계 파이프라인 구조
- 명령어 파이프라인의 단계 수 , N = 2
  - 단계 1 : 명령어 인출(instruction fetch, IF)
  - 단계 2 : 명령어 실행(instruction execution, IE)

<img width="985" alt="스크린샷 2025-03-17 오후 3 02 31" src="https://github.com/user-attachments/assets/fd221499-05ce-42a1-9ee3-d94c3e3cbd7f" />

## 4단계 파이프라인 구조
- 명령어 파이프라인의 단계 수, N = 4
  - 단계 1 : 명령어 인출(instruction fetch, IF)
  - 단계 2 : 명령어 해독(instruction decode, ID)
  - 단계 3 : 연산 실행(execution, EX)
  - 단계 4 : 연산결과 저장(wrtie-back, WB)
<img width="951" alt="스크린샷 2025-03-17 오후 3 08 03" src="https://github.com/user-attachments/assets/f7fcc3b0-708d-4a75-a9f3-2d1c379c2959" />

### 파이프라인의 속도상승
- 병렬 계산 않을 때 명령어 처리에 걸리는 총 시간
  - 단계 수 N, 명령어 개수 i, 각 단계 시간 T
<img width="384" alt="스크린샷 2025-03-17 오후 3 56 46" src="https://github.com/user-attachments/assets/f3435918-d64a-4523-8ef6-d9913ad99a16" />

- 이 구조가 전체 명령어 처리에 걸리는 총 시간
  - 첫 명령어 통과에 N x T 시간
  - 두 번째 명령어부터 나머지 i - 1개는 주기 T씩 추가
<img width="384" alt="스크린샷 2025-03-17 오후 3 56 58" src="https://github.com/user-attachments/assets/a9b99e1a-03c5-40ba-b773-b6c1d28bdb84" />

- 파이프라인 구조 사용 시 병령 계산의 속도 상승

<img width="384" alt="스크린샷 2025-03-17 오후 3 57 24" src="https://github.com/user-attachments/assets/ab1cab86-909f-4a4e-93c1-be71a8949a0e" />

명령어 수 i -> ∞  : 단계 수 N에 근접한다.

## 슈퍼 파이프라인
- 기존 파이프라인의 단계 수는 유지하면 각 단계 내에서 처리 속도를 몇 배로 높여주는 CPU 설계 기술
  - 단계 내부에서 더 작은 단계들로 세분화시키고 클럭 속도를 높여 빠르게 처리
- 슈퍼 파이프라인 차수 sp를 정의
  - 파이프라인 구조의 한 단계 내에서 처리 속도를 몇 배로 높이는지 나타내는 비율

<img width="956" alt="스크린샷 2025-03-17 오후 3 52 57" src="https://github.com/user-attachments/assets/56ea13c5-eb58-4589-b036-dd0eb50133c5" />

### 슈퍼 파이프라인의 속도 상승
- 슈퍼 파이프라인 차수 sp
  - 단계 수 N, 명령어 개수 i, 각 단계 시간은 T로 동일
- 이 구조가 전체 명령어 처리에 걸리는 총 시간
  - 첫 명령어 통과 N x T 시간
  - 두 번째 명령어 부터 나머지 i - 1개는 T / sp 씩 추가

<img width="384" alt="스크린샷 2025-03-17 오후 3 56 22" src="https://github.com/user-attachments/assets/6156ee70-d0be-4ae7-bcc4-9374022b366a" />

- 슈퍼 파이프라인 구조 사용시 병령 계산의 속도 상승
<img width="384" alt="스크린샷 2025-03-17 오후 3 56 01" src="https://github.com/user-attachments/assets/1d8ae2e8-73e3-433e-a954-f055c7490c3c" />


## 파이프라인의 제약조건
- 파이프라인의 단계 수를 늘릴 수록 대체로 속도상승 비율은 좋아진다.
  - 하지만 이론적인 최대치까지 개선되지는 않는다.
- 시스템 자원 사용에 충돌이 없어야 한다.
  - 다른 단계에서 메모리나 입출력장치 등 시스템 자원을 먼저 차지해 사용하고 있으면 기다려야 한다.
- 명령어 간에 상호 의존성이 없어야 한다.
  - 명령어 1 : R1 <- R2 + R3 (R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1에 저장)
  - 명령어 2 : R4 <- R1 + R5 (R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4에 저장)
- 모든 명령어가 같은 단계를 거쳐야 낭비가 없다.
- 각 단계의 처리시간이 동일해야 한다.
- 명령어는 순차적으로 실행되어야 한다.
  - 인터럽트나 서브루틴으로 분기가 발생하면 파이프라인에 있던 명령어들을 버리게 되므로 처리가 지연된다.

## 슈퍼스칼라 구조
- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조 (오늘날의 멀티 스레드 프로세)
슈퍼스칼라 차수 ss = 3, 파이프라인 단계 N = 4
<img width="901" alt="스크린샷 2025-03-17 오후 4 09 20" src="https://github.com/user-attachments/assets/c0612c3f-81ce-44eb-a8d7-09993c42bfd9" />


- 이론적으로는 파이프라인 개수에 비례하여 속도 증가
  - 하지만 파이프라인 위험도의 증가로 인해 파이프라인 개수에 비례하여 처리 속도가 증가하진 않는다.
### 슈퍼스칼라와 슈퍼 파이프라인
슈퍼 파이프라인 차수 sp = 2, 슈퍼스칼라 차수 ss = 3, 파이프라인 단계 N = 4
<img width="907" alt="스크린샷 2025-03-17 오후 4 11 20" src="https://github.com/user-attachments/assets/b01a19c2-189f-4a26-96fc-3d79ea07bc55" />


### 슈퍼스칼라와 슈퍼 파이프라인의 속도 상승
- 슈퍼 파이프라인 차수 sp, 슈퍼스칼라 차수 ss
  - 단계 수 N, 명령어 개수 i, 각 단계 시간은 T로 동일
- 이 구조가 전체 명령어 처리에 걸리는 총 시간
  - 명령어는 i / ss 세트로 나누어진다.
  - 첫 명령어 세트 통과 N x T 시간
  - 두 번째 세트부터 나머지 i / ss - 1 세트는 T / sp 씩 추가

<img width="527" alt="스크린샷 2025-03-17 오후 4 13 44" src="https://github.com/user-attachments/assets/e5aa6774-83da-4925-8fa5-53dc07c2cbb2" />

- 슈퍼스칼라와 슈퍼 파이프라인 병렬계산의 속도 상승

<img width="555" alt="스크린샷 2025-03-17 오후 4 14 10" src="https://github.com/user-attachments/assets/2ec3f3c1-8f40-4ac6-930d-0ccb753a8def" />

- 명령어 i -> ∞ : sp x ss x N에 접근
